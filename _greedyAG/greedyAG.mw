<?xml version="1.0" encoding="UTF-8"?>
<Worksheet>
<Version major="2021" minor="0"/>
<Label-Scheme value="2" prefix=""/>
<View-Properties presentation="true" autoexpanding_sections="true" UserProfileName="Maple Default Profile" NumericFormat-ApplyInteger="true" NumericFormat-ApplyRational="true" NumericFormat-ApplyExponent="false" editable="true">
</View-Properties>
<MapleNet-Properties prettyprint="3" warnlevel="3" compactdisplay="false" preplot="" helpbrowser="standard" displayprecision="-1" echo="1" scientificx="true" unitattributes="&quot;fontweight&quot; = &quot;bold&quot;" imaginaryunit="I" longdelim="true" elisiontermsthreshold="10000" elisiondigitsafter="100" elisiondigitsbefore="100" plotdevice="inline" errorbreak="1" plotoptions="" plotdriver="opengl" quiet="false" elisiontermsbefore="100" elisiontermsafter="100" historytimestamp="false" screenwidth="79" indentamount="4" plotoutput="terminal" screenpixelheight="768" rtablesize="[10, 10]" useclientjvm="true" format="worksheet" labelwidth="20" postplot="" typesetting="extended" ansi="false" ansicolor="[]" elisiondigitsthreshold="10000" showassumed="1" ansilprint="false" trailingsemicolon="true" errorcursor="false" labelling="true" screenheight="25" prompt="&gt; " verboseproc="1" latexwidth="8.0" ShowLabels="false"/>
<Styles>
<Font name="Heading 1" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Warning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Line Printed Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 2" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="16" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Inert Output" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[144,144,144]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 3" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="14" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Diagnostic" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[40,120,40]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 1" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[120,0,14]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 2" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 3" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 5" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Header and Footer" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkError" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Atomic Variable" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[175,0,175]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkWarning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Dictionary Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[147,0,15]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="2D Math" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Bullet Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Plot" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="List Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Dash Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Input" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Error" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Normal" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Caption Reference" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Code" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input Placeholder" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[200,0,200]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="true"/>
<Font name="Equation Label" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Author" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,128,128]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Caption Text" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Layout name="Heading 1" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="4" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Warning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 4" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Line Printed Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 2" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="2" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Output" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.3" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 3" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Diagnostic" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 1" alignment="left" bullet="numeric" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Text Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="newline" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 2" alignment="left" bullet="alphabetic" firstindent="0" leftmargin="36" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 3" alignment="left" bullet="roman" firstindent="0" leftmargin="72" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 4" alignment="left" bullet="ALPHABETIC" firstindent="0" leftmargin="108" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 5" alignment="left" bullet="ROMAN" firstindent="0" leftmargin="144" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Annotation Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkError" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkWarning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Bullet Item" alignment="left" bullet="dot" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Plot" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="List Item" alignment="left" bullet="indent" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Dash Item" alignment="left" bullet="dash" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Error" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Normal" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Author" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="8" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Pencil-style name="Pencil 1" pen-color="[0,0,0]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 2" pen-color="[0,0,255]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 3" pen-color="[0,0,0]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 4" pen-color="[0,0,255]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 5" pen-color="[255,0,0]" pen-height="5.0" pen-width="5.0" pen-opacity="1.0"/>
<Highlighter-style name="Highlighter 5" pen-color="[255,255,0]" pen-height="48.0" pen-width="48.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 3" pen-color="[51,255,0]" pen-height="24.0" pen-width="24.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 4" pen-color="[0,255,255]" pen-height="32.0" pen-width="32.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 1" pen-color="[255,153,255]" pen-height="12.0" pen-width="8.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 2" pen-color="[255,204,0]" pen-height="14.0" pen-width="14.0" pen-opacity="0.8"/>
</Styles>
<Startup-Code startupcode=""/>
<Task-table>
    <Task-category name="&lt;default&gt;"/>
</Task-table>
<Task/><Presentation-Block>
<Group hide-output="false" labelreference="L4443" drawlabel="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### collection of functions for automatic generating elimination templates and Matlab solvers</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4464" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">restart:</Text-field>
</Input>
</Group>
<Group view="code" hide-input="false" hide-output="false" labelreference="L4466" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group></Presentation-Block>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Basis finder</Text-field></Title>
<Group hide-output="false" labelreference="L5129" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### read minimal problem, output list of polynomials and list of variables
readProblem := proc(prob::string)
    local fn := cat(&quot;../problems/F_&quot;, prob, &quot;.m&quot;), F:
    if not FileTools[Exists](fn) then error(&quot;file %1 not found&quot;, fn): end if:
    read fn:
    F := map(expand, eval(cat(F_, prob))):
    F, [op(indets(F))]:
end proc:</Text-field>
</Input>
</Group><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L5054" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### check if monomials from M are linearly independent
isLinIndep := proc(M, G, tord, pp)
    local vars := indets(G), S:
    if nops(M) = 1 then return true: end if:
    S := poly2matrix(convert(map(m-&gt;Groebner[NormalForm](m, G, tord, characteristic=pp), M), list), vars)[1]:
    is(LinearAlgebra[Modular][Rank](pp, S) &lt;&gt; LinearAlgebra[Modular][Rank](pp, S[1..-2, ..])):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5056" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### check if M contains a basis
testBasis := proc(M, deg, G, tord, pp)
    local vars := indets(G), S:
    if nops(M) &lt; deg then return false, &lt;&lt;0&gt;&gt;: end if:
    S := poly2matrix(convert(map(m-&gt;Groebner[NormalForm](m, G, tord, characteristic=pp), M), list), vars)[1]:
    `if`(pp &lt;&gt; 0, is(LinearAlgebra[Modular][Rank](pp, S) = deg), is(LinearAlgebra[Rank](S) = deg)), S:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5052" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### generate initial set of monomials
iniMonSet := proc(F, deg, vars, G, tord, pp, dom)
    local E, M, vr, d, flag, S, d_min := 0:
    E := convert(map(op, Groebner[Support](F)), set): ### set of monomials occuring in the original equations
    printf(&quot;Support: %a <Font encoding="UTF-8">monomials\134n</Font>&quot;, nops(E)):
    M := E:
    for d from 0 while d-d_min &lt;= dom do
        vr := select(x-&gt;degree(x, vars) &lt;= d, M):
        M := map(t-&gt;op(t*~vr), M):
        flag, S := testBasis(M, deg, G, tord, pp):
        if not flag then d_min := d+1: end if:
    end do:
    printf(&quot;Initial set: %a <Font encoding="UTF-8">monomials\134n</Font>&quot;, nops(M)):
    return E, M:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-input="false" hide-output="false" labelreference="L5050" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### neighboring monomials
neighborMons := proc(B, MB, vars)
    local nB, b, v:
    if nops(B) = 0 then return MB: end if:
    nB := select(type, map(op, map(op@{`*`~, `/`~}, B, vars)), monomial):
    nB := (nB minus B) intersect MB:
    `if`(nops(nB) = 0, MB, nB):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5051" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### use random sampling for basis construction
genBasis := proc(E, M, deg, vars, G, tord, pp)
    local rnd := rand(0..1000)/1000, B := {}, EB, MB := M, nB, nB1, bv, k, a, nv := nops(vars), wt, m, i:
    randomize(): # reset the seed for rnd()
    bv := [seq(round(rnd()), i=1..nv)]: ### random binary list
    k := max[index](map(x-&gt;x+rnd()/100., bv)):
    a := vars[k]: ### select action variable for guiding the sampling
    while nops(B) &lt; deg do
        MB minus= B: ### linearly independent monomials in M
        nB := neighborMons(B, MB, vars): ### list of neighboring monomials of B in MB
        EB := E union B:
        wt := x-&gt;`if`(x in E,1,0)+`if`(a*x in EB,1,0)+add(bv[i]*degree(x,vars[i]),i=1..nv)+rnd()/100.:
        nB1 := sort([op(nB)], (x,y)-&gt;wt(x)&gt;=wt(y)): ### sort nB w.r.t. weights
        m, i := nB1[1], 1:
        while not isLinIndep([op(B), m], G, tord, pp) and i &lt; nops(nB1) do
            i += 1:
            m := nB1[i]:
        end do:
        B := {op(B), m}: ### update B
    end do:
    return B:
end proc:</Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L5053" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### read non-standard bases
readBases := proc(prob::string)
    local st := 1, QBs := [], fn := cat(&quot;bases/b_&quot;, prob):
    if not FileTools[Exists](fn) then error(&quot;file %1 not found&quot;, fn): end if:
    while st &lt;&gt; 0 do
        st := readline(fn):
        if st &lt;&gt; 0 then QBs := [op(QBs), parse(st)]: end if:
    end do:
    <Font encoding="UTF-8">printf(&quot;%a quotient space bases loaded\134n&quot;, </Font>nops(QBs)):
    return QBs:
end proc:</Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L5057" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### generate and save non-standard monomial bases of the quotient ring
### this is a reimplementation of the random sampling strategy from
### V. Larsson et al., Beyond Grobner bases: Basis selection for minimal solvers, CVPR 2018
basisFinder := proc(prob::string, {number_of_bases::posint:=100, deg_over_min::nonnegint:=0, prime_number::posint:=32749, mode := APPEND})
    local pp := prevprime(prime_number+1), F, vars, tord, G, deg, E, M := [], BB, B, fn := cat(&quot;bases/b_&quot;, prob), fd:
    F, vars := readProblem(prob):
    tord := tdeg(op(vars)):
    G := Groebner[Basis](F, tord, characteristic=pp):
    deg := nops(Groebner[NormalSet](G, tord)[1]):
    E, M := iniMonSet(F, deg, vars, G, tord, pp, deg_over_min):
    BB := `if`(mode=APPEND, readBases(prob), []):
    fd := fopen(fn, mode):
    while nops(BB) &lt; number_of_bases do
        B := genBasis(E, M, deg, vars, G, tord, pp):
        if not member(B, BB) then
            BB := [op(BB), B]:
            <Font encoding="UTF-8">fprintf(fd, &quot;%a\134n&quot;, </Font>convert(B, list)):
            <Font encoding="UTF-8">printf(&quot;%d%% completed\134n&quot;, </Font>round(nops(BB)/number_of_bases*100)):
        end if:
    end do:
    fclose(fd):
end proc:</Text-field>
</Input>
</Group></Presentation-Block>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Monomial ordering and change matrix finder</Text-field></Title><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L5084" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### write data for Grobner fan computation in Gfan
writeGfan := proc(prob::string, {prime_number::posint:=32749})
    local pp := prevprime(prime_number+1), F, vars, fd := fopen(&quot;gfan/igf&quot;, WRITE):
    F, vars := readProblem(prob):
    F := map(expand, convert(F, set)) mod pp:
    <Font encoding="UTF-8">fprintf(fd, &quot;Z/%aZ%a\134n%a&quot;, pp, vars, F):
</Font>    fclose(fd):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5087" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### read data from a file generated by Gfan
readGfan := proc(fn::string)
    local flag := false, st := 1, n := 0, pp, i:
    if not FileTools[Exists](fn) then error(&quot;file %1 not found&quot;, fn): end if:
    st := readline(fn):
    pp := parse(st[3..StringTools[FirstFromLeft](&quot;[&quot;, st)-2]): # read prime number
    while st &lt;&gt; 0 do
        st := readline(fn):
        if st = &quot;{{&quot; or st = &quot;{&quot; then
            flag := true:
            n += 1:
            G||n := []:
        elif flag and st[-1] &lt;&gt; &quot;}&quot; then
            G||n := [op(G||n), st[1..-2]]:
        elif flag and st[-1] = &quot;}&quot; then
            G||n := [op(G||n), st[1..-2]]:
            flag := false:
        end if:
    end do:
    return pp, [seq(map(parse, G||i), i=1..n)], [seq(map(x-&gt;parse(x[1..StringTools[FirstFromLeft](&quot;+&quot;, x)-1]), G||i), i=1..n)]:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5086" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### find monomial ordering which is compatible with a given Grobner basis and leading monomial
### in case of error, try to increase depthlimit option
getTord := proc(gb, lm)
    local vars := [op(indets(gb))], nv := nops(vars), i, k, sbt := [0 $ nv]=NULL, degs := [seq(d||i, i=1..nv)], gbdegs, lmdegs, ineqs, sol, weights, g:
    gbdegs := map(z-&gt;map(x-&gt;map(vr-&gt;degree(x, vr), vars), convert(z, list)), gb):
    lmdegs := map(x-&gt;map(vr-&gt;degree(x, vr), vars), lm):
    ineqs := {seq(op(map(x-&gt;add(x*~degs)&gt;=1, subs(sbt, [seq(lmdegs[k]-g, g in gbdegs[k])]))), k=1..nops(gb))}:
    sol := Optimization[Minimize](add(degs), ineqs, <Font opaque="false" subscript="false" underline="false" superscript="false" bold="true" foreground="[120,0,14]" italic="false" executable="true" selection-placeholder="false" size="12" readonly="false" background="[255,255,255]" style="Help Maple Name" placeholder="false" family="Courier New" font_style_name="Help Maple Name">depthlimit=40</Font>, assume=nonnegint)[2]:
    weights := subs(sol, degs):
    weights, <Font opaque="false" subscript="false" underline="false" superscript="false" bold="true" foreground="[120,0,14]" italic="false" executable="true" selection-placeholder="false" size="12" readonly="false" background="[255,255,255]" style="Help Maple Name" placeholder="false" family="Courier New" font_style_name="Help Maple Name">wdeg(</Font>weights<Font opaque="false" subscript="false" underline="false" superscript="false" bold="true" foreground="[120,0,14]" italic="false" executable="true" selection-placeholder="false" size="12" readonly="false" background="[255,255,255]" style="Help Maple Name" placeholder="false" family="Courier New" font_style_name="Help Maple Name">, vars):</Font>
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5130" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### read weight file
readWeights := proc(fn::string)
    local st := 1, Ws := []:
    if not FileTools[Exists](fn) then error(&quot;file %1 not found&quot;, fn): end if:
    while st &lt;&gt; 0 do
        st := readline(fn):
        if st &lt;&gt; 0 then Ws := [op(Ws), parse(st)]: end if:
    end do:
    printf(&quot;%a <Font encoding="UTF-8">weight vectors loaded\134n</Font>&quot;, nops(Ws)):
    Ws:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5089" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### write weight file
writeWeights := proc(prob::string, {number_of_weights::posint:=100, rand_range::[posint,posint]:=[200,800], prime_number::posint:=32749, mode := APPEND})
    local pp := prevprime(prime_number+1), Gs, LMs, WW, gffn := cat(&quot;gfan/gf_&quot;, prob), fn := cat(&quot;weights/w_&quot;, prob), fd, i, W, F, vars, rnd, tord, G:
    if FileTools[Exists](gffn) then
        <Font encoding="UTF-8">printf(&quot;Generating weight vectors from Gfan file\134n&quot;):</Font>
        pp, Gs, LMs := readGfan(gffn):
        WW := [seq(getTord(Gs[i], LMs[i])[1], i=1..nops(Gs))]:
        fd := fopen(fn, WRITE):
<Font encoding="UTF-8">        for W in WW do fprintf(fd, &quot;%a\134n&quot;, W</Font>): end do:
        fclose(fd):
    else
        <Font encoding="UTF-8">printf(&quot;Gfan file not found\134n&quot;):
        printf(&quot;Generating %a random weight vectors\134n&quot;, </Font>number_of_weights):
        F, vars := readProblem(prob):
        rnd := rand(rand_range[1]..rand_range[2]):
        randomize(): # reset the seed for rnd()
        WW := `if`(mode=APPEND, readWeights(fn), []):
        fd := fopen(fn, mode):
        while nops(WW) &lt; number_of_weights do
            tord := wdeg([seq(rnd(), i=1..nops(vars))], vars):
            G := Groebner[Basis](F, tord, characteristic=pp):
            W := getTord(G, Groebner[LeadingMonomial](G, tord))[1]:
            if not member(W, WW) then
                WW := [op(WW), W]:
                <Font encoding="UTF-8">fprintf(fd, &quot;%a\134n&quot;, W</Font>):
                <Font encoding="UTF-8">printf(&quot;%d%% completed\134n&quot;, </Font>round(nops(WW)/number_of_weights*100)):
            end if:
        end do:
        fclose(fd):
    end if:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5085" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### write data for change matrix computation in Macaulay2
writeCM := proc(prob::string, {prime_number::posint:=32749})
    local Ws0, pp := prevprime(prime_number+1), fn := cat(&quot;weights/w_&quot;, prob), fd, F, sF, vars, Ws:
    Ws0 := readWeights(fn):
    Ws := StringTools[SubstituteAll](StringTools[SubstituteAll](convert(Ws0, string), &quot;[&quot;, &quot;(&quot;), &quot;]&quot;, &quot;)&quot;):
    F, vars := readProblem(prob):
    vars := convert(vars, string):
    sF := convert(map(expand, F) mod pp, string):
    fd := fopen(&quot;cm/icm&quot;, WRITE):
    <Font encoding="UTF-8">fprintf(fd, &quot;Ws = %s;\134npp = %a;\134nvr = %s;\134n</Font>&quot;, Ws, pp, vars):
    fprintf(fd, &quot;f<Font encoding="UTF-8"> = openOut &quot;&quot;cm_%s&quot;&quot;;\134n&quot;, prob):</Font>
    fprintf(fd, &quot;f<Font encoding="UTF-8"> &lt;&lt; toString(pp) &lt;&lt; endl;\134n</Font>&quot;):
    fprintf(fd, &quot;f<Font encoding="UTF-8"> &lt;&lt; toString(vr) &lt;&lt; endl;\134n</Font>&quot;):
    fprintf(fd, &quot;<Font encoding="UTF-8">for i from 0 to %a do (\134n&quot;, </Font>nops(Ws0)-1):
    fprintf(fd, &quot;f<Font encoding="UTF-8"> &lt;&lt; toString(Ws#i) &lt;&lt; endl;\134n</Font>&quot;):
    if has(F, I) then fprintf(fd, &quot;R = ZZ/pp[I]/(I^2+1)%s, &quot;, vars[1..-2]):
    else fprintf(fd, &quot;R = ZZ/pp%s, &quot;, vars[1..-2]):
    end if:
    fprintf(fd, &quot;<Font encoding="UTF-8">MonomialOrder =&gt; Weights =&gt; Ws#i];\134n</Font>&quot;):
<Font encoding="UTF-8">    fprintf(fd, &quot;J = ideal(%s);\134n&quot;, sF[2..-2]):
</Font>    fprintf(fd, &quot;<Font encoding="UTF-8">G = gb(J,ChangeMatrix=&gt;true);\134nM = getChangeMatrix G;\134n</Font>&quot;):
    fprintf(fd, &quot;f<Font encoding="UTF-8"> &lt;&lt; toString(M) &lt;&lt; endl;\134n);\134n</Font>&quot;):
    fprintf(fd, &quot;f &lt;&lt; close;&quot;):
    fclose(fd):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5088" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### read pre-computed change matrices
readCM := proc(prob::string)
    local st := 1, fn := cat(&quot;cm/cm_&quot;, prob), pp, vars, m := 0, n := 0, i:
    if not FileTools[Exists](fn) then error(&quot;file %1 not found&quot;, fn): end if:
    pp := parse(readline(fn)): # read prime number
    vars := parse(readline(fn)): # read variables
    while st&lt;&gt;0 do
        st := readline(fn):
        if st&lt;&gt;0 and st[1]=&quot;(&quot; then
            m += 1:
            T||m := st[2..-2]:
        elif st&lt;&gt;0 and st[1..6]=&quot;matrix&quot; then
            n += 1:
            CM||n := StringTools[SubstituteAll](StringTools[SubstituteAll](st[9..-2], &quot;{&quot;, &quot;[&quot;), &quot;}&quot;, &quot;]&quot;):
        end if:
    end do:
    <Font encoding="UTF-8">printf(&quot;%d change matrices loaded\134n&quot;, n):</Font>
    return pp, [seq(wdeg([parse(T||i)], vars), i=1..m)], [seq(Matrix([map(parse, CM||i)])^+, i=1..n)]:
end proc:</Text-field>
</Input>
</Group></Presentation-Block>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Template finder</Text-field></Title><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L5059" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### save data needed to construct template
saveData := proc(prob::string, mn::[posint,posint], sp::numeric, pp::posint, vars::{list,set}, av::monomial, tord::ShortMonomialOrder, QB::list, shifts::list, pols::list, std::boolean)
    local fn := `if`(std, cat(&quot;optim/o_std_&quot;, prob), cat(&quot;optim/o_nstd_&quot;, prob)), fd, mn0, sp0, flag := false:
    if FileTools[Exists](fn) then
        fd := fopen(fn, READ):
        mn0 := parse(readline(fn)):
        sp0 := parse(readline(fn)):
        if mn[1] &lt; mn0[1] or (mn[1] = mn0[1] and sp &gt; sp0) then flag := true: end if: # smaller or sparser template found
        fclose(fd):
    else
        flag := true:
    end if:
    if flag then
        fd := fopen(fn, WRITE):
        <Font encoding="UTF-8">fprintf(fd, &quot;%a\134n%a\134n%a\134n%a\134n%a\134n%a\134n%a\134n%a\134n%a\134n%a&quot;, mn, sp, pp</Font>, convert(vars, list), av, tord, QB, shifts, pols, []):
        fclose(fd):
    end if:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5062" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### read data needed to construct template
readData := proc(prob::string, std::boolean)
    local fn := `if`(std, cat(&quot;optim/o_std_&quot;, prob), cat(&quot;optim/o_nstd_&quot;, prob)), fd, mn, sp, pp, vars, av, tord, QB, shifts, pols, xE0:
    if not FileTools[Exists](fn) then error(&quot;file %1 not found&quot;, fn): end if:
    fd := fopen(fn, READ):
    mn := parse(readline(fn)):
    sp := parse(readline(fn)):
    pp := parse(readline(fn)):
    vars := parse(readline(fn)):
    av := parse(readline(fn)):
    tord := parse(readline(fn)):
    QB := parse(readline(fn)):
    shifts := parse(readline(fn)):
    pols := parse(readline(fn)):
    xE0 := parse(readline(fn)):
    fclose(fd):
    mn, sp, pp, vars, av, tord, QB, map(eval, shifts), pols, xE0:
end proc:</Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L5024" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### solve polynomial system by the action matrix method
eigenSolver := proc(F::list(polynom))
    local rnd, fB2C, vars := [op(indets(F))], tord := tdeg(op(vars)), G, B, deg, av, vr, T, V, S, Sr:
    rnd := rand(-1000..1000)/1000: # uniformly distributed random rational numbers from [-1, 1]
    fB2C := proc(f::polynom, vars::list, B::list)
        local t := table(zip((a,b)-&gt;b=a, [coeffs(f, vars, 'm')], [m])):
        return map(b-&gt;`if`(assigned(t[b]), t[b], 0), B):
    end proc:
    if not type(F, list(polynom)) then error(&quot;The case of non-polynomial system is not handled&quot;): end if:
    G := Groebner[Basis](F, tord):
    B := Groebner[NormalSet](G, tord)[1]:
    deg := nops(B):
    av := add(vr*rnd(), vr in vars):
    T := Groebner[MultiplicationMatrix](av, B, table(B=~[$1..deg]), G, tord):
    V := LinearAlgebra[Eigenvectors](evalf(T))[2]:
    V := V/~(Vector(deg, fill=1).V[1]):
    S := Matrix(map(vr-&gt;fB2C(Groebner[NormalForm](vr, G, tord), vars, B), vars)).V:
    Sr := Re(S[.., select(c-&gt;andseq(is(S[i,c], real), i=1..op([1,1], S)), [$1..op([1,2], S)])]):
    return S, Sr:
end proc:</Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group hide-output="false" labelreference="L5040" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">srt := (v::{list,set,Vector}, tord::ShortMonomialOrder)-&gt;sort(v, (x, y)-&gt;Groebner[TestOrder](y, x, tord)):</Text-field>
</Input>
</Group>
<Group view="code" labelreference="L5140" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### support of polynomial f
supp := (f, vars)-&gt;{op(Groebner[Support](expand(f), vars))}:</Text-field>
</Input>
</Group>
<Group view="code" labelreference="L5137" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### support of polynomial system F
Supp := (F, vars)-&gt;{op(map(op, Groebner[Support](F, vars)))}:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L5041" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### transform list of polynomials into coefficient (Macaulay) matrix and monomial vector
poly2matrix := proc(F, vars)
    local T := map(pl-&gt;table(zip((a,b)-&gt;b=a, [coeffs(pl, vars, 'mn')], [mn])), F), B := [op(Supp(F, vars))]:
    return Matrix(map(t-&gt;map(b-&gt;`if`(assigned(t[b]), t[b], 0), B), T)), Vector(B):
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L5037" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### permute columns of matrix M
permuteColumns := (M, V, V1)-&gt;local mn: M[.., [seq(ListTools[Search](mn, V), mn in V1)]]:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5029" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### compute sparsity of matrix M
sparsity := proc(M::Matrix)
    local numzr := nops(select(`=`, convert(M, list), 0)):
    return numzr/mul(op(1, M)):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5042" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### compute change-of-basis matrix S
matrixS := proc(B, B0, G, tord, pp)
    local S, V0, deg := nops(B):
    if nops(B0) &lt;&gt; deg then error(&quot;lists B0 and B must have the same length&quot;): end if:
    S, V0 := poly2matrix(map(b-&gt;Groebner[NormalForm](b, G, tord, characteristic=pp), B), indets(G)):
    if op(1, V0) = deg then
        return permuteColumns(S, V0, Vector(B0)):
    else # should never get here
        error(&quot;failed to construct matrix S&quot;):
    end if:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5043" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">quotients := proc(g, G, tord, pp)
    Groebner[NormalForm](g, G, tord, 'Q', characteristic=pp):
    return Q:
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L5033" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">monPartition := proc(av, Gr, tord, pp, QB:=[])
    local B0, B, aB, R, B2, RB, G, nG, T, S, i:
    B0 := Groebner[NormalSet](Gr, tord)[1]:
    B := convert(`if`(QB = [], B0, QB), set):
    aB := av*~B:
    R := srt(convert(aB minus B, list), tord):
    nG := nops(R):
    B2 := (aB intersect B)/~av:
    B := [op(srt(convert(B minus B2, list), tord)), op(srt(convert(B2, list), tord))]:
    RB, aB := [op(R), op(B)], av*~B:
    if QB = [] then
        T := Groebner[MultiplicationMatrix](av, B, table(Equate(B, [$ 1..nops(B)])), Gr, tord, characteristic=pp):
    else
        T := Groebner[MultiplicationMatrix](av, B0, table(Equate(B0, [$ 1..nops(B0)])), Gr, tord, characteristic=pp):
        S := matrixS(B, B0, Gr, tord, pp):
        T := `if`(pp &lt;&gt; 0, S.T.LinearAlgebra[Modular][Inverse](pp, S) mod pp, S.T.LinearAlgebra[MatrixInverse](S)): # new action matrix
    end if:
    G := convert(Vector(R) - T[1..nG, ..].Vector(B), list):
    return aB, B, RB, T, G, Matrix([seq(quotients(G[i], Gr, tord, pp), i=1..nG)]):
end proc:</Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L5046" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### iteratively construct matrix H of size nG x nF
matrixHi := proc(F, G, vars, pp)
    local undetPoly, pv := add(vars), nF := nops(F), nG := nops(G), uH, leqs, sol, i, dF := map(degree, F, vars), dG, d, d_min, h, j, p, k:
    undetPoly := proc(vars, pv, d, j)
        local mons:
        coeffs(expand(1 + add(pv^p, p=1..d)), vars, 'mons'):
        mons := [mons]:
        add(mons[k]*_v[j, k], k=1..nops(mons)):
    end proc:
    for i from 1 to nG do
        d_min, dG := 0, map(x-&gt;max(0, x), [degree(G[i], vars) $ nF] - dF):
        for d from 0 while d-d_min &lt;= 0 do
            uH := [seq(undetPoly(vars, pv, dG[j]+d, j), j=1..nF)]:
            leqs := {coeffs(expand(-G[i]+add(uH[j]*F[j], j=1..nF)), vars)}:
            sol := msolve(leqs, pp):
            if nops({sol})=0 then d_min := d+1: end if:
        end do:
        h[i] := map(expand@eval, uH, sol) mod pp:
    end do:
    return &lt;seq(Vector[row](h[i]), i=1..nG)&gt;:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5028" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### use known change matrix to non-iteratively construct matrix H of size nG x nF
matrixHni := proc(F, G, C, CM, vars, pp)
    local undetPolyni, nF := nops(F), nG := nops(G), H0, uH, leqs, sol, pars, i, j, k:
    undetPolyni := proc(h, vars, i, j)
        local mons:
        coeffs(h, vars, 'mons'):
        mons := [mons]:
        add(mons[k]*_v[i, j, k], k=1..nops(mons)):
    end proc:
    H0 := map(expand, C.CM) mod pp:
    uH := Matrix(nG, nF, (i,j)-&gt;undetPolyni(H0[i,j], vars, i, j)):
    pars := {seq(_u[i], i=1..nops(indets(uH) minus vars))}:
    leqs := map(coeffs, {seq(expand(-G[i] + add(uH[i, j]*F[j], j=1..nF)) mod pp, i=1..nG)}, vars):
    sol := msolve(leqs, pars, pp):
    return map(expand@eval, uH, sol) mod pp:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5034" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### generate syzygy module
syzModule := proc(F::{list,set,Vector}, G::list, A::Matrix, tord::ShortMonomialOrder, pp::nonnegint)
    local nF := nops(F), nG := nops(G), e, L, Lt, M, S, B, i, j:
    e := seq(Vector(nG, {i=1}), i=1..nG): # standard basis in R^n
    L := [seq([Groebner[LeadingTerm](G[i], tord)], i=1..nG)]: # leading coefficients and monomials
    Lt := map(x-&gt;x[1]*x[2], L): # leading terms
    M := Matrix(nG, (i, j)-&gt;lcm(L[i][2], L[j][2])/Lt[i]):
    S := [seq(seq(M[i, j]*e[i] - M[j, i]*e[j] - &lt;quotients(M[i, j]*G[i] - M[j, i]*G[j], G, tord, pp)&gt;, j=i+1..nG), i=1..nG)]:
    S := Matrix(S)^+:
    B := Matrix([seq(quotients(F[i], G, tord, pp), i=1..nF)]):
    S := map(expand, &lt;S.A, LinearAlgebra[IdentityMatrix](nF) - B.A&gt;):
    if pp &lt;&gt; 0 then S := S mod pp: end if:
    return S[remove(i-&gt;ArrayTools[IsZero](S[i, ..]), [$ 1..op([1,1], S)]), ..]:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5030" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### syzygy-based construction of matrix H of size nG x nF
matrixHsyz := proc(F::{list,set,Vector}, G::list, C::Matrix, A::Matrix, tord::ShortMonomialOrder, pp::nonnegint)
    local S, Theta:
    S := syzModule(F, G, A, tord, pp):
    Theta := Matrix(op([1,1], C),op([1,1],S), (i,j)-&gt;t[i,j]):
    return map(expand, C.A + Theta.S) mod pp:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5044" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### try to fix incomplete template by adding more shifts
fixTemplate := proc(admons, F, vars, mon, RB)
    local nF := nops(F), monF := map(f-&gt;supp(f, vars), F), admon := [{} $ nF], i, j, Q, flag, xF, M, V0, E, V, mon1, mn:
    for i from 1 to nops(admons) do
        flag := false:
        for j from 1 to nF do
            Q := map(mf-&gt;`if`(divide(admons[i], mf, 'q'), q, NULL), monF[j]):
            if Q &lt;&gt; {} then admon[j] := {op(admon[j]), Q[1]}: flag := true: break: end if:
        end do:
        if not flag then error(&quot;failed to correct template&quot;): end if:
    end do:
    mon1 := [seq(convert(convert(mon[j], set) union admon[j], Vector), j=1..nF)]:
    xF := [seq(seq(expand(F[j]*mn), mn in mon1[j]), j=1..nF)]:
    M, V0 := poly2matrix(xF, vars):
    E := convert(V0, set) minus convert(RB, set):
    E := srt([op(E)], tdeg(op(vars))):
    V := &lt;op(E), op(RB)&gt;:
    <Font encoding="UTF-8">printf(&quot;Template fixed\134n&quot;):</Font>
    return mon1, M, V0, V:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5038" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### construct elimination template from either matrix H or a list of expansion monomials
constructTemplate := proc(H, F, vars, RB)
    local nF := nops(F), mon, xF, M, V0, E, V, j, mn:
    mon := `if`(type(H, Matrix), [seq(&lt;op(Supp(convert(H[.., j], list), vars))&gt;, j=1..nF)], H):
    xF := [seq(seq(expand(F[j]*mn), mn in mon[j]), j=1..nF)]: # expanded polynomial system
    M, V0 := poly2matrix(xF, vars): # matrix form of xF, M.V0 = v(xF)
    E := convert(V0, set) minus convert(RB, set): # set of excessive monomials
    E := srt([op(E)], tdeg(op(vars))):
    V := &lt;op(E), op(RB)&gt;: # monomial vector
    if op(1, V) &lt;&gt; op(1, V0) then # template is incomplete, try to fix
        <Font encoding="UTF-8">printf(&quot;Template is incomplete\134n&quot;):</Font>
        mon, M, V0, V := fixTemplate(convert(V, set) minus convert(V0, set), F, vars, mon, RB):
    end if:
    mon, permuteColumns(M, V0, V), V: # reorder columns of M w.r.t. permutation from V0 to V
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L5035" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### adjust parameters
adjustParams := proc(F, H, RB, vars, pp)
    local nF := nops(F), nG := op([1,1], H), H1 := H, Lm, cols, L, mon, V0, E, e, sm, rm, np, ss, prm, leqs, sol, j, i:
    Lm := seq(poly2matrix(convert(H[.., j], list), vars), j=1..nF):
    cols := [seq(remove(x-&gt;membertype(posint, convert(Lm[2*j-1][.., x], list)), [$ 1..op([1,2], Lm[2*j-1])]), j=1..nF)]:
    L, mon := [seq(Lm[2*j-1][.., cols[j]], j=1..nF)], [seq(Lm[2*j][cols[j]], j=1..nF)]:
    sm := [seq(map(t-&gt;supp(expand(F[j]*t), vars), mon[j]), j=1..nF)]:
    V0 := convert(map(op, map(op@convert, sm, set)), set): # set of all monomials in the expanded system
    E := convert(V0 minus convert(RB, set), list): # list of excessive monomials
    sm := Vector(sm):
    rm := map(e-&gt;select(i-&gt;member(e, sm[i]), {$ 1..op(1, sm)}), E):
    np := [seq(`+`(seq(nops(select(has, rm, rm[j][i])), i=1..nops(rm[j]))), j=1..nops(rm))]:
    ss := (i, j, rm, np)-&gt;(nops(rm[i]) &gt; nops(rm[j])) or (nops(rm[i]) = nops(rm[j]) and np[i] &gt; np[j]):
    ### reorder excessive monomials so that first are monomials requiring setup of smaller number of parameters
    prm := sort([$ 1..nops(E)], (i, j)-&gt;ss(i, j, rm, np)):
    E := E[prm]: # sorted list of excessive monomials
    ### start adjusting parameters
    for e in E do
        Lm := seq(poly2matrix(convert(H1[.., j], list), vars), j=1..nF):
        L, mon := [seq(Lm[2*j-1], j=1..nF)], [seq(Lm[2*j], j=1..nF)]:
        if nops(indets(L))=0 then break: end if: # nothing to adjust
        sm := [seq(map(t-&gt;supp(expand(F[j]*t), vars), mon[j]), j=1..nF)]:
        rm := map(x-&gt;{ListTools[SearchAll](1, map(y-&gt;nops(y intersect {e}), x))}, sm):
        leqs := {seq(op(map(k-&gt;op(convert(L[j][.., k], set)), rm[j])), j=1..nF)}:
        sol := msolve(leqs, pp):
        if nops({sol})=0 then next: end if:
        H1 := map(expand@eval, H1, sol) mod pp:
    end do:
    constructTemplate(H1, F, vars, RB):
end proc:</Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group hide-output="false" labelreference="L5036" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### check if the action matrix found
isActionMatrixFound := proc(T::Matrix, M::Matrix, aB::list, B::list, nG::posint, pp::nonnegint)
    local tM, T1, deg := nops(B), m := deg - nG, r, k:
    tM := Gaussjord(M, 'r') mod pp: # r is for rank
    T1 := &lt;-tM[r-nG+1..r, -deg..-1], Matrix(m, deg, {seq((m-k+1, ListTools[Search](aB[-k], B)) = 1, k=1..m)})&gt; mod pp:
    LinearAlgebra[Equal](T, T1):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5039" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### Schur complement reduction of the template
SchurReduction := proc(M::Matrix, V::Vector, shifts, nE::nonnegint, pp::posint, pols::list)
    local rg, crg, m, M1, bs, M2, tM2, r, M3, tM3, M4, basis, lindep, B1, B2, B3, B4, iB1, rperm, cperm, p, i:
    if nops(pols)=0 then return M, V, 0, [], []: end if:
    rg := [seq(op([$ add(op(1, shifts[i]), i=1..p-1)+1..add(op(1, shifts[i]), i=1..p)]), p in pols)]:
    m := nops(rg):
    crg := [op({$ 1..op([1, 1], M)} minus {op(rg)})]:
    M1 := &lt;M[rg, ..], M[crg, ..]&gt;:
    M2 := M1[1..m, 1..nE]:
    tM2 := Gaussjord(M2^+, 'r') mod pp:
    basis := map(i-&gt;ListTools[Search](1, convert(tM2[i], list)), {$ 1..r}):
    lindep := convert({$ 1..op([1, 2], tM2)} minus basis, list):
    rperm := convert([op(basis), op(lindep), $ m+1..op([1,1], M1)], list):
    rperm := ([op(rg), op(crg)])[rperm]:
    M3 := &lt;M1[[op(basis)], ..], M1[[op(lindep)], ..], M1[m+1..-1, ..]&gt;:
    tM3 := Gaussjord(M3[1..m, 1..nE], 'r') mod pp:
    basis := map(i-&gt;ListTools[Search](1, convert(tM3[i], list)), {$ 1..r}):
    lindep := convert({$ 1..op([1, 2], tM3)} minus basis, list):
    cperm := [op(basis), op(lindep), $ nE+1..op([1,2], M3)]:
    M4 := &lt;M3[.., [op(basis)]]|M3[.., [op(lindep)]]|M3[.., nE+1..-1]&gt;:
    B1, B2, B3, B4 := M4[1..r, 1..r], M4[1..r, r+1..-1], M4[r+1..-1, 1..r], M4[r+1..-1, r+1..-1]:
    iB1 := LinearAlgebra[Modular][Inverse](pp, B1):
    B4 - B3.iB1.B2 mod pp, V[[op(lindep), $ nE+1..op(1, V)]], r, rperm, cperm:
end proc:</Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L5026" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### remove dependent rows and columns from the template
linDepReduction := proc(M::Matrix, pp::nonnegint)
    local r, tM, M1, tM1, basis, r2del, c2del:
    ### remove linearly dependent rows
    tM := Gaussjord(M^+, 'r') mod pp:
    basis := map(i-&gt;ListTools[Search](1, convert(tM[i], list)), {$ 1..r}):
    r2del := convert({$ 1..op([1,2], tM)} minus basis, list):
    M1 := M[remove(`in`, [$ 1..op([1,1], M)], r2del), ..]:
    ### remove linearly dependent columns
    tM1 := Gaussjord(M1, 'r') mod pp:
    basis := map(i-&gt;ListTools[Search](1, convert(tM1[i], list)), {$ 1..r}):
    c2del := convert({$ 1..max(basis)} minus basis, list):
    return M1[.., remove(`in`, [$ 1..op([1,2], M1)], c2del)], r2del, c2del:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5031" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### rectify monomial ordering by heuristics
rectTord := proc(F::{list,set,Vector}, vars::list, Ts::list, pp::nonnegint)
    local nF := nops(F), dg, wt, nn, GBs, Ws, vr, i:
    dg := [seq(add(map(degree, F, vr))/nF, vr in vars)]:
    wt := 1/~dg:
    nn := lcm(op(map(denom, wt))):
    wt := nn*wt:
    GBs := map(x-&gt;Groebner[Basis](F, x, characteristic=pp), Ts):
    Ws := [op({seq(getTord(GBs[i], Groebner[LeadingMonomial](GBs[i], Ts[i]))[1], i=1..nops(GBs))})]:
    Ws := map(z-&gt;z*~wt, Ws):
    map(x-&gt;wdeg(x, vars), Ws):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5032" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### filter out some quotient space bases
filterBases := proc(F, QBs, nQBs, ff)
    local mF, Bs, prm, N := round(ff*nQBs):
    mF := Supp(F, indets(F)): # support of F
    Bs := map(x-&gt;nops(convert(x, set) intersect mF), QBs):
    prm := sort(Bs, `&gt;`, output=permutation):
    <Font encoding="UTF-8">printf(&quot;%d quotient space bases removed\134n&quot;, N):</Font>
    [op(1..nQBs-N, prm)]:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5090" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">filterBases2 := proc(nF, vars, CMs, GBs, Ts, QBs, pp, ff)
    local Gr, tord, B, CM, nQBs := nops(CMs), deg := nops(QBs[1]), i, vB, tB, mp, av, aB, T, G, C, H, cHs, m, avo, ms := [], mo := 10^6, prm, N := round(ff*nQBs), k, c:
    for i from 1 to nQBs do
        Gr, tord, B, CM := GBs[i], Ts[i], QBs[i], CMs[i]:
        if nops(B) &lt;&gt; deg then next: end if:
        vB, tB, mp := Vector(B), table(B=~[$1..deg]), 10^6:
        for av in vars do
            aB := av*~B:
            T := Groebner[MultiplicationMatrix](av, B, tB, Gr, tord, characteristic=pp):
            G := Vector(aB)-T.vB:
            C := Matrix([seq(quotients(G[k], Gr, tord, pp), k=1..deg)]):
            H := map(expand, C.CM) mod pp:
            cHs := [seq(add(H[.., k]), k=1..nF)]:
            m := add(`if`(type(c, `+`), nops(c), 1), c in cHs):
            if m&lt;mp then mp := m: avo := av: end if:
        end do:
        if mp &lt; mo then mo := mp: <Font encoding="UTF-8">printf(&quot;Smaller template found: %d,%a\134n&quot;, mo, avo):</Font> end if:
        ms := [op(ms), mp]:
    end do:
    prm := sort(ms, `&lt;`, output=permutation):
    <Font encoding="UTF-8">printf(&quot;%d quotient space bases removed\134n&quot;, N):</Font>
    [op(1..nQBs-N, prm)]:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5045" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### initialize minimal problem
iniProb := proc(prob::string, std::boolean, ff::numeric, pn::posint)
    local F, vF, pp := pn, vars, GBs, Ts, GC, QBs, CMs, tord, CM, G, q, nQBs, i:
    F, vars := readProblem(prob):
    vF, vars := Vector(F), {op(vars)}:
    tord := tdeg(op(vars)):
    <Font encoding="UTF-8">printf(&quot;The problem is defined by %d polynomials\134n&quot;, </Font>nops(F)):
    G := Groebner[Basis](F, tord, characteristic=pp):
    if Groebner[HilbertDimension](G, characteristic=pp)&lt;&gt;0 then error(&quot;the problem has infinitely many solutions&quot;): end if:
    <Font encoding="UTF-8">printf(&quot;Variables: %a; degrees: %a; number of roots: %d\134n&quot;, </Font>[op(vars)], map(degree, F), nops(Groebner[NormalSet](G, tord)[1])):
    if std then # use standard bases
        pp, Ts, CMs := readCM(prob): # read change matrices and monomial orderings
        nQBs := nops(CMs):
        GBs := [seq(map(expand, convert(CMs[i].vF, list)) mod pp, i=1..nQBs)]:
        QBs := [seq(Groebner[NormalSet](GBs[i], Ts[i])[1], i=1..nQBs)]: # compute quotient space bases
        q := filterBases2(nops(F), vars, CMs, GBs, Ts, QBs, pp, ff):
        CMs, GBs, Ts, QBs := [seq(CMs[i], i in q)], [seq(GBs[i], i in q)], [seq(Ts[i], i in q)], [seq(QBs[i], i in q)]:
    else # use non-standard bases
        QBs := readBases(prob):
        nQBs, tord := nops(QBs), tdeg(op(vars)):
        GC := Groebner[Basis](F, tord, characteristic=pp, output=extended): # compute Grobner bases and change matrices
        G, CM := GC[1], Matrix(GC[2]):
        q := filterBases(F, QBs, nQBs, ff):
        CMs, GBs, Ts, QBs := [seq(CM, i in q)], [seq(G, i in q)], [seq(tord, i in q)], [seq(QBs[i], i in q)]:
    end if:
    return pp, F, vars, GBs, Ts, QBs, CMs:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5027" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### find templates for a given minimal problem
templateFinder := proc(prob::string, {basis::symbol:=std, prime_number::posint:=32749, action_vars::list({posint,negint}):=[], schur_pols::list({posint,negint}):=[], filter_frac::numeric:=0})
    local pp := prevprime(prime_number+1), F, vars, GBs, Ts, QBs, CMs, avars, nv, deg, nQBs, N, i, j, Gr, tord, QB, CM, tord1, av, aB, B, RB, T, G, C, nG, H, shifts, M, V, fl, m, n, sp, mo := 10^6, no, spo := -1:
    pp, F, vars, GBs, Ts, QBs, CMs := iniProb(prob, evalb(basis=std), filter_frac, pp):
    avars := `if`(nops(action_vars)=0, vars, map(a-&gt;vars[a], action_vars)):
    nv, deg, nQBs := nops(avars), nops(QBs[1]), nops(QBs):
    N := 100/(nQBs*nv):
    for i from 1 to nQBs do
        Gr, tord, QB, CM := GBs[i], Ts[i], QBs[i], CMs[i]:
        tord1 := op(1, tord):
        for j from 1 to nv do
            av := avars[j]:
            aB, B, RB, T, G, C := monPartition(av, Gr, tord, pp, QB):
            nG := nops(G):
            H := `if`(basis=nstd, matrixHi(F, G, vars, pp), matrixHni(F, G, C, CM, vars, pp)): # construct matrix H
            shifts, M, V := adjustParams(F, H, RB, vars, pp): # adjust parameters and return template M and monomial vector V
            M := SchurReduction(M, V, shifts, op([1,2], M)-deg-nG, pp, schur_pols)[1]: # reduce template by the Schur complement reduction
            M := linDepReduction(M, pp)[1]: # remove linearly dependent rows and columns from M
            fl := isActionMatrixFound(T, M, aB, B, nG, pp): # check if M is a template (optional)
            m, n := op(1, M): # template dimension
            sp := sparsity(M): # template sparsity
            if fl and (m &lt; mo or (m = mo and sp &gt; spo)) then
                mo, no, spo := m, n, sp:
                <Font encoding="UTF-8">printf(&quot;Smaller or sparser template found: [%d,%d],%a,%a,%a\134n&quot;, m, n, evalf(sp,3), av, `if`(basis=nstd, i, tord1)):</Font>
                saveData(prob, [m, n], evalf(sp,5), pp, vars, av, tord, B, shifts, schur_pols, evalb(basis=std)):
            elif not fl then # should never get here
                error(&quot;invalid action matrix: %1,%2,%3&quot;, i, av, tord):
            end if:
            <Font encoding="UTF-8">printf(&quot;%d%s,[%d,%d],%a,%a,%a\134n&quot;, round(((i-1)*nv+j)*N), &quot;%&quot;, m, n, evalf(sp,3), av, `if`(basis=nstd, i, tord1)):</Font>
        end do:
    end do:
    <Font encoding="UTF-8">printf(&quot;Best template: [%d,%d], %a\134n&quot;, mo, no, evalf(spo,3)):</Font>
end proc:</Text-field>
</Input>
</Group></Presentation-Block>
</Section>
<Section collapsed="true" isCollapsible="true" drawButton="true" MultipleChoiceAnswerIndex="-1" MultipleChoiceRandomizeChoices="false" TrueFalseAnswerIndex="-1" EssayAnswerRows="5" EssayAnswerColumns="60"><Title><Text-field style="Heading 1" layout="Heading 1">Matlab solver generator</Text-field></Title>
<Group hide-output="false" labelreference="L5127" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">getB0 := proc(P::set, vars::{list,set})
    local nv := nops(vars), i, Vrs, vrs, B0:
    for i from 0 to nv-1 do
        Vrs := combinat[choose](vars, nv-i):
        for vrs in Vrs do
            B0 := select(m-&gt;convert(map(vr-&gt;member(vr*m, P), vrs), `and`), P):
            if nops(B0)&lt;&gt;0 then return convert(map(vr-&gt;vr*B0[1], [op(vrs), 1]), set): else B0 := {}: end if:
        end do:
    end do:
end proc:</Text-field>
</Input>
</Group><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L5018" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### read template data
readTemplate := proc(prob::string, std::boolean)
    local mn0, sp0, pp, vars, av, tord, shifts, schur_pols, F, C, U0, tord0, U, Gr, aB, B1, B, R, B2, B0, RB, T, G, S, deg, nR, M1, V, V1, r, rperm, cperm, M, tM1, t1, r2del, c2del, E, mn, xE, xV, xE0:
    mn0, sp0, pp, vars, av, tord, B, shifts, schur_pols, xE0 := readData(prob, std):
    F := readProblem(prob)[1]:
    C, U0 := poly2matrix(F, vars):
    tord0 := tdeg(op(vars)):
    U := srt(U0, tord0):
    C := permuteColumns(C, U0, U):
    Gr := Groebner[Basis](F, tord, characteristic=pp):
    B1 := Groebner[NormalSet](Gr, tord)[1]:
    B := convert(B, set):
    aB := av*~B:
    R := srt(convert(aB minus B, list), tord):
    deg, nR := nops(B), nops(R):
    B2 := (aB intersect B)/~av:
    B0 := getB0(B2, vars):
    B2 := [op(srt(convert(B2 minus B0, list), tord)), op(srt(convert(B0, list), tord))]:
    B := [op(srt(convert(B minus convert(B2, set), list), tord)), op(B2)]:
    RB, aB := [op(R), op(B)], av*~B:
    T := Groebner[MultiplicationMatrix](av, B1, table(Equate(B1, [$ 1..nops(B1)])), Gr, tord, characteristic=pp):
    S := matrixS(B, B1, Gr, tord, pp):
    T := S.T.LinearAlgebra[Modular][Inverse](pp, S) mod pp:
    G := convert(Vector(R) - T[1..nR, ..].Vector(B), list):
    M1, V1 := constructTemplate(shifts, F, vars, RB)[2..3]:
    M1, V, r, rperm, cperm := SchurReduction(M1, V1, shifts, op([1,2], M1)-deg-nR, pp, schur_pols):
    M, r2del, c2del := linDepReduction(M1, pp):
    <Font encoding="UTF-8">printf(&quot;Action matrix found: %a\134n&quot;, isActionMatrixFound(T, M, aB, B, nR, pp)):</Font>
    mn := [op(1, M)]:
    <Font encoding="UTF-8">printf(&quot;Template size: %a\134n&quot;, mn):</Font>
    if mn0[1]&lt;&gt;mn[1] or mn0[2]&lt;&gt;mn[2] then error(&quot;wrong template&quot;): end if:
    xV := convert(V1, set) minus convert(V, set):
    V := V[remove(`in`, [$ 1..op(1, V)], c2del)]:
    tM1 := Gaussjord(M1[remove(`in`, [$ 1..op([1,1], M1)], r2del), ..]) mod pp:
    t1 := map(x-&gt;op(select(y-&gt;tM1[y,x]&lt;&gt;0, {$ 1..op([1,1], tM1)})), {op(c2del)}):
    xE := convert(xE0, set) union convert(V[[op(t1)]], set): # this set of monomials is needed for column pivoting
    E := srt(convert(convert(V, set) minus convert(RB, set), list), tord0): # list of excessive monomials
    vars, av, C, U, E, RB, B, aB, shifts, r2del, c2del, mn, nR, xE, r, rperm, cperm, xV:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5017" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### compute data for column-pivoting
iniColpiv := proc(V::Vector, xE::set, av::monomial, vars::list)
    local Vl, P, B0, aP, R, RP, E, tord := tdeg(op(vars)):
    Vl := convert(convert(V, set) minus xE, list):
    P := convert(select(m-&gt;member(av*m, Vl), Vl), set): # set of permissible monomials
    B0 := getB0(P, vars):
    aP := av*~P:
    R := srt(convert(aP minus P, list), tord):
    P := [op(srt(convert(P minus B0, list), tord)), op(srt(convert(B0, list), tord))]:
    <Font encoding="UTF-8">printf(&quot;List of permissible monomials:\134n%a\134n&quot;, P):
    printf(&quot;Number of permissible monomials: %d\134n&quot;, nops(P)):</Font>
    aP := map(m-&gt;ListTools[Search](av*m, [op(P), op(R)]), P):
    RP := [op(R), op(P)]:
    E := srt(convert(convert(Vl, set) minus convert(RP, set) union xE, list), tord):
    &lt;op(E), op(RP)&gt;, P, aP, nops(R), nops(E):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5104" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### alternate elements of list v with commas and convert it to string
alterComma := (v::list)-&gt;cat(&quot;[&quot;, op(ListTools[Interleave](v, [&quot;,&quot; $ nops(v)-1])), &quot;]&quot;):</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5078" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### write Matlab solver without column-pivoting
writeSolver := proc(dir::string, mn0, vars0, av, iM, eM, B, aB, mn, nE, nR, r, std)
    local vars1, vv, fd, nv0 := nops(vars0), deg := nops(B), i, fb := &quot;    &quot;:
    vars1 := convert(convert(vars0, set) minus {av}, list):
    vv := [seq(ListTools[Search](vars1[i]*B[-1], B), i=1..nv0-1)]:
    fd := fopen(cat(dir, &quot;/&quot;, `if`(std, &quot;std_&quot;, &quot;nstd_&quot;), mn[1]-r, &quot;x&quot;, mn[2]-r, &quot;_&quot;, prob, &quot;.m&quot;), WRITE):
    fprintf(fd, cat(&quot;%% Input: coefficient matrix C of size &quot;, mn0[1], &quot;x&quot;, mn0[2], &quot;<Font encoding="UTF-8">\134n\134n&quot;)):</Font>
    fprintf(fd, cat(&quot;function &quot;, alterComma(vars0), &quot; = &quot;, `if`(std, &quot;std_&quot;, &quot;nstd_&quot;), mn[1]-r, &quot;x&quot;, mn[2]-r, &quot;_&quot;, prob, <Font encoding="UTF-8">&quot;(C)\134n\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;i_dx = &quot;, alterComma(map(i-&gt;i[1], iM)),<Font encoding="UTF-8"> &quot;;\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;j_dx = &quot;, alterComma(map(i-&gt;i[2], iM)),<Font encoding="UTF-8"> &quot;;\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;C_dx = &quot;, alterComma(eM),<Font encoding="UTF-8"> &quot;;\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;<Font encoding="UTF-8">M = sparse(i_dx,j_dx,C(C_dx),&quot;, mn[1], &quot;,&quot;, mn[2], &quot;);\134n&quot;)):</Font>
    if r&lt;&gt;0 then
<Font encoding="UTF-8">        fprintf(fd, cat(&quot;\134n&quot;, fb, &quot;M = M(&quot;, r+1, &quot;:end,&quot;, r+1, &quot;:end)-(M(&quot;, r+1, &quot;:end,1:&quot;, r, &quot;)/M(1:&quot;, r, &quot;,1:&quot;, r, &quot;))*M(1:&quot;, r, &quot;,&quot;, r+1, &quot;:end); %% Schur complement reduction\134n&quot;))</Font>:
    end if:
<Font encoding="UTF-8">    fprintf(fd, cat(&quot;\134n&quot;, fb, &quot;</Font>[L,~,Pi] = lu(M(:,1:&quot;, nE, &quot;));<Font encoding="UTF-8">\134n&quot;)):
</Font>    fprintf(fd, cat(fb, &quot;Pi = <Font encoding="UTF-8">Pi';\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;<Font encoding="UTF-8">M = [Pi*L Pi(:,&quot;, nE+1, &quot;:end)]\134\134M</Font>(:,&quot;, nE+1, &quot;:end)<Font encoding="UTF-8">;\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;M = M(end-&quot;, nR-1, &quot;:end,:)<Font encoding="UTF-8">;\134n&quot;)):</Font>
    fprintf(fd, cat(<Font encoding="UTF-8">&quot;\134n&quot;, </Font>fb, &quot;T<Font encoding="UTF-8"> = zeros(&quot;, deg, &quot;);\134n&quot;)):
</Font>    fprintf(fd, cat(fb, &quot;T(1:&quot;, nR, &quot;,:) = -M(:,1:&quot;, nR, &quot;)<Font encoding="UTF-8">\134\134</Font>M(:,&quot;, nR+1, &quot;:end)<Font encoding="UTF-8">;\134n&quot;)):</Font>
    if deg-nR = 1 then
        fprintf(fd, cat(fb, &quot;T(&quot;, deg*ListTools[Search](aB[-1], B)<Font encoding="UTF-8">, &quot;) = 1;\134n&quot;)):</Font>
    elif deg-nR &gt; 1 then
        fprintf(fd, cat(fb, &quot;T(&quot;, alterComma([seq(deg*(ListTools[Search](aB[i-deg-1], B)-1)+i, i=nR+1..deg)])<Font encoding="UTF-8">, &quot;) = 1;\134n&quot;)):</Font>
    end if:
<Font encoding="UTF-8">    fprintf(fd, cat(&quot;\134n&quot;, fb, &quot;[V,D] = eig(T);\134n&quot;)):
</Font>    if nops(vv)=1 then
        fprintf(fd, cat(fb, &quot;sol = [V(&quot;, vv[1], &quot;,:)./V(&quot;, deg, &quot;,:)<Font encoding="UTF-8">; diag(D).'];\134n\134n&quot;)):</Font>
    else
        fprintf(fd, cat(fb, &quot;sol = [V(&quot;, alterComma(vv), &quot;,:)./repmat(V(&quot;, deg, &quot;,:),<Font encoding="UTF-8">&quot;, nv0-1, &quot;,1); diag(D).'];\134n\134n&quot;)):</Font>
    end if:
    fprintf(fd, cat(fb, &quot;<Font encoding="UTF-8">I = find(not(isnan(sol(1,:))) &amp; not(isinf(sol(1,:))));\134n</Font>&quot;)):
    <Font encoding="UTF-8">fprintf(fd, cat(fb, &quot;%%I = I(not(imag(sol(1,:)))); %% uncomment this line for real roots only\134n</Font>&quot;)):
    for i from 1 to nv0-1 do
        fprintf(fd, cat(fb, vars1[i], &quot; = sol(&quot;, i, &quot;,I)<Font encoding="UTF-8">;\134n&quot;)):</Font>
    end do:
    fprintf(fd, cat(fb, av, &quot; = sol(&quot;, nv0, &quot;,I)<Font encoding="UTF-8">;\134n\134n&quot;)):</Font>
    fprintf(fd, &quot;end&quot;):
    fclose(fd):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5076" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### write Matlab solver with column-pivoting
writeSolverColpiv := proc(dir::string, mn0, vars0, av, iM, eM, P, aP, mn, nE, nR, deg, r, std)
    local vars1, vv, fd, nv0 := nops(vars0), nP := nops(P), i, fb := &quot;    &quot;:
    vars1 := convert(convert(vars0, set) minus {av}, list):
    vv := [seq(ListTools[Search](vars1[i]*P[-1], P[-deg..-1]), i=1..nv0-1)]:
    fd := fopen(cat(dir, &quot;/&quot;, `if`(std, &quot;std_&quot;, &quot;nstd_&quot;), mn[1]-r, &quot;x&quot;, mn[2]-r, &quot;_colpiv_&quot;, prob, &quot;.m&quot;), WRITE):
    fprintf(fd, cat(&quot;%% Input: coefficient matrix C of size &quot;, mn0[1], &quot;x&quot;, mn0[2], &quot;<Font encoding="UTF-8">\134n\134n&quot;)):</Font>
    fprintf(fd, cat(&quot;function &quot;, alterComma(vars0), &quot; = &quot;, `if`(std, &quot;std_&quot;, &quot;nstd_&quot;), mn[1]-r, &quot;x&quot;, mn[2]-r, &quot;_colpiv_&quot;, prob, &quot;<Font encoding="UTF-8">(C)\134n\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;i_dx = &quot;, alterComma(map(i-&gt;i[1], iM)),<Font encoding="UTF-8"> &quot;;\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;j_dx = &quot;, alterComma(map(i-&gt;i[2], iM)),<Font encoding="UTF-8"> &quot;;\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;C_dx = &quot;, alterComma(eM),<Font encoding="UTF-8"> &quot;;\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;<Font encoding="UTF-8">M = sparse(i_dx,j_dx,C(C_dx),&quot;, mn[1], &quot;,&quot;, mn[2], &quot;);\134n&quot;)):</Font>
    if r&lt;&gt;0 then
<Font encoding="UTF-8">        fprintf(fd, cat(&quot;\134n&quot;, fb, &quot;M = M(&quot;, r+1, &quot;:end,&quot;, r+1, &quot;:end)-(M(&quot;, r+1, &quot;:end,1:&quot;, r, &quot;)/M(1:&quot;, r, &quot;,1:&quot;, r, &quot;))*M(1:&quot;, r, &quot;,&quot;, r+1, &quot;:end); %% Schur complement reduction\134n&quot;))</Font>:
    end if:
    if nE &lt;&gt; 0 then
<Font encoding="UTF-8">        fprintf(fd, cat(&quot;\134n&quot;, fb, &quot;</Font>[L,~,Pi] = lu(M(:,1:&quot;, nE, &quot;));<Font encoding="UTF-8">\134n&quot;)):
</Font>        fprintf(fd, cat(fb, &quot;Pi = <Font encoding="UTF-8">Pi';\134n&quot;)):</Font>
        fprintf(fd, cat(fb, &quot;<Font encoding="UTF-8">M = [Pi*L Pi(:,&quot;, nE+1, &quot;:end)]\134\134M(:,&quot;, nE+1, &quot;:end);\134n&quot;)):</Font>
        fprintf(fd, cat(fb, &quot;<Font encoding="UTF-8">M = full(M(&quot;, nE+1, &quot;:end,:));\134n&quot;)):</Font>
    else
        fprintf(fd, cat(fb, &quot;<Font encoding="UTF-8">M = full(M);\134n&quot;)):</Font>
    end if: 
    if nR &lt;&gt; 0 then
        fprintf(fd, cat(<Font encoding="UTF-8">&quot;\134n&quot;, </Font>fb, &quot;[L,UR,Pi] = lu(M(:,1:&quot;, nR, &quot;));<Font encoding="UTF-8">\134n&quot;)):</Font>
        fprintf(fd, cat(fb, &quot;Pi = <Font encoding="UTF-8">Pi';\134n&quot;)):</Font>
        fprintf(fd, cat(fb, &quot;M = [Pi*L Pi(:,&quot;<Font encoding="UTF-8">, nR+1, &quot;:end)]\134\134M(:,&quot;, nR+1, &quot;:end);\134n&quot;</Font>)):
    end if:
    fprintf(fd, cat(fb, &quot;MP = M(1:&quot;, nR, &quot;,:)<Font encoding="UTF-8">;\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;NP = M(&quot;, nR+1, &quot;:end,:)<Font encoding="UTF-8">;\134n\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;[Q<Font encoding="UTF-8">,U,Pi] = qr(NP(:,1:end-&quot;, nv0+1, &quot;));\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;<Font encoding="UTF-8">A = UR\134\134[MP(:,1:end-&quot;, nv0+1, &quot;)*Pi MP(:,end-&quot;, nv0, &quot;:end)];\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;B = U(:,1:&quot;, mn[1]-r-nE<Font encoding="UTF-8">-nR, &quot;)\134\134[U(:,&quot;, </Font>mn[1]-r-nE-nR+1, &quot;:end) Q'*NP(:,end-&quot;, nv0, &quot;:end)];<Font encoding="UTF-8">\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;M = [-A(:,end-&quot;, deg-1, &quot;:end)+A(:,1:end-&quot;, deg, &quot;)*B; -B];<Font encoding="UTF-8">\134n\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;xP = &quot;, alterComma(aP), &quot;<Font encoding="UTF-8">;\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;P1 = [(1:&quot;, nP-nv0-1, &quot;)*Pi &quot;, nP-nv0, &quot;:&quot;, nP, &quot;];<Font encoding="UTF-8">\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;T = getT(M,[&quot;, nP+1, &quot;:&quot;, nP+nR, &quot; P1(1:end-&quot;, deg, &quot;)],P1(end-&quot;, deg-1, &quot;:end)&quot;, &quot;,xP)<Font encoding="UTF-8">;\134n&quot;)):</Font>
    <Font encoding="UTF-8">fprintf(fd, cat(&quot;\134n&quot;, fb, &quot;[V,D] = eig(T);\134n&quot;)):
</Font>    if nops(vv)=1 then
        fprintf(fd, cat(fb, &quot;sol = [V(&quot;, vv[1], &quot;,:)./V(&quot;, deg, &quot;,:)<Font encoding="UTF-8">; diag(D).'];\134n\134n&quot;)):</Font>
    else
        fprintf(fd, cat(fb, &quot;sol = [V(&quot;, alterComma(vv), &quot;,:)./repmat(V(&quot;, deg, &quot;,:),<Font encoding="UTF-8">&quot;, nv0-1, &quot;,1); diag(D).'];\134n\134n&quot;)):</Font>
    end if:
    fprintf(fd, cat(fb, &quot;<Font encoding="UTF-8">I = find(not(isnan(sol(1,:))) &amp; not(isinf(sol(1,:))));\134n</Font>&quot;)):
<Font encoding="UTF-8">    fprintf(fd, cat(fb, &quot;%%I = I(not(imag(sol(1,:)))); %% uncomment this line for real roots only\134n</Font>&quot;)):
    for i from 1 to nv0-1 do
        fprintf(fd, cat(fb, vars1[i], &quot; = sol(&quot;, i, &quot;,I)<Font encoding="UTF-8">;\134n&quot;)):</Font>
    end do:
    fprintf(fd, cat(fb, av, &quot; = sol(&quot;, nv0, &quot;,I)<Font encoding="UTF-8">;\134n\134n&quot;)):</Font>
    fprintf(fd, &quot;end&quot;):
    fclose(fd):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5109" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeInidataCoefs := proc(prob::string, root_dir::string)
    local proc_name, _C, _name, _size, Cs, Cl, dir, fd, i, e, idx, fb := &quot;    &quot;:
    read &quot;../problems/_common.m&quot;:
    read cat(&quot;../problems/F_&quot;, prob, &quot;.m&quot;):
    proc_name := eval(cat(C_, prob)):
    _C, _name, _size := proc_name():
    dir := cat(root_dir, &quot;/&quot;, prob):
    if not FileTools[Exists](dir) then FileTools[MakeDirectory](dir): end if:
    ### write inidata file
    fd := fopen(cat(dir, &quot;/inidata_&quot;, prob, &quot;.m&quot;), WRITE):
    fprintf(fd, cat(&quot;<Font encoding="UTF-8">function data = inidata_&quot;, prob, &quot;()\134n&quot;)):
</Font>    fprintf(fd, cat(fb, &quot;<Font encoding="UTF-8">data = cell([1,&quot;, nops(_size), &quot;]);\134n&quot;)):
</Font>    for i from 1 to nops(_size) do
        fprintf(fd, cat(fb, &quot;data{&quot;, i, &quot;} = randn(&quot;, alterComma(_size[i])[2..-2]<Font encoding="UTF-8">, &quot;);\134n&quot;)):
</Font>    end do:
    fprintf(fd, &quot;end&quot;):
    fclose(fd):
    ### write coefs file
    fd := fopen(cat(dir, &quot;/coefs_&quot;, prob, &quot;.m&quot;), WRITE):
<Font encoding="UTF-8">    fprintf(fd, cat(&quot;function C = coefs_&quot;, prob, &quot;(data)\134n\134n&quot;)):</Font>
    for i from 1 to nops(_name) do
<Font encoding="UTF-8">        fprintf(fd, cat(fb, _name[i], &quot; = data{&quot;, i, &quot;};\134n&quot;)):</Font>
    end do:
    <Font encoding="UTF-8">fprintf(fd, &quot;\134n&quot;):</Font>
    for i from 1 by 2 to nops(_C) do
        if _C[i]=cf then
            fprintf(fd, cat(fb, &quot;C = zeros(&quot;, op([1,1], _C[-1]), &quot;,&quot;, op([1,2], _C[-1]), &quot;);<Font encoding="UTF-8">\134n\134n&quot;)):</Font>
            Cs, Cl := convert(_C[i+1], set) minus {0}, convert(_C[i+1], list):
            for e in Cs do
                idx := [ListTools[SearchAll](e, Cl)]:
                fprintf(fd, cat(fb, &quot;C(&quot;, `if`(nops(idx)=1, idx[1], alterComma(idx)), &quot;) = &quot;, convert(e, string), &quot;;<Font encoding="UTF-8">\134n&quot;)):</Font>
            end do:
        ### TODO
        #elif _C[i]=rref then
        #    fprintf(fd, cat(fb, &quot;C = rref(C);<Font encoding="UTF-8">\134n&quot;)):</Font>
        end if:
    end do:
    <Font encoding="UTF-8">fprintf(fd, cat(&quot;\134n&quot;, fb, &quot;C = C./repmat(sqrt(sum(C.*conj(C),2)),1,size(C,2));\134n\134n&quot;)):</Font>
    fprintf(fd, &quot;end&quot;):
    fclose(fd):
    read &quot;greedyAG.m&quot;:
end proc:</Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L5108" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeTestNum := proc(prob::string, deg::posint, mn::[posint,posint], vars::list, vars0::list, U::Vector, basis, root_dir, cp)
    local dir := cat(root_dir, &quot;/&quot;, prob), fd, j, fb := &quot;    &quot;, fb2 := cat(fb, fb), vv := map(vr-&gt;cat(vr, vr), vars), vv0 := map(vr-&gt;cat(vr, vr), vars0), xvars := convert(convert(vars, set) minus convert(vars0, set), list), xvv := map(vr-&gt;cat(vr, vr), xvars):
    if not FileTools[Exists](dir) then FileTools[MakeDirectory](dir): end if:
    fd := fopen(cat(dir, &quot;/test_num_&quot;, prob, &quot;.m&quot;), WRITE):
<Font encoding="UTF-8">    fprintf(fd, &quot;rng(23);\134n\134n&quot;):
</Font>    fprintf(fd, &quot;<Font encoding="UTF-8">N = 10000;\134n\134n&quot;):
</Font>    fprintf(fd, cat(&quot;Err_&quot;, prob, &quot; = [];<Font encoding="UTF-8">\134nTm_&quot;, prob, &quot; = [];\134n\134n</Font>&quot;)):
    fprintf(fd, &quot;for i = 1:N<Font encoding="UTF-8">\134n\134n&quot;):</Font>
    fprintf(fd, cat(fb, &quot;data = inidata_&quot;, prob, &quot;(); %% generate initial data of the problem<Font encoding="UTF-8">\134n\134n&quot;)):
</Font>    fprintf(fd, cat(fb, &quot;try<Font encoding="UTF-8">\134n</Font>&quot;)):
    fprintf(fd, cat(fb2, &quot;tic;<Font encoding="UTF-8">\134n</Font>&quot;)):
<Font encoding="UTF-8">    fprintf(fd, cat(fb2, &quot;C = coefs_&quot;, prob, &quot;(data); %% compute coefficients of polynomial system\134n&quot;)):</Font>
    fprintf(fd, cat(fb2, alterComma(vv0), &quot; = &quot;, `if`(evalb(basis=std), &quot;std_&quot;, &quot;nstd_&quot;), mn[1], &quot;x&quot;, mn[2], `if`(cp, &quot;_colpiv_&quot;, &quot;_&quot;), prob, &quot;(C); %% solve polynomial system<Font encoding="UTF-8">\134n&quot;)):</Font>
    if nops(xvv)&lt;&gt;0 then
        fprintf(fd, cat(fb2, `if`(nops(xvv)=1, xvv[1], alterComma(xvv)), &quot; = arrayfun(@(j) get_&quot;, cat(op(xvars)), &quot;(C,&quot;, alterComma([seq(cat(vv0[j], &quot;(j)&quot;), j=1..nops(vv0))])[2..-2], &quot;), 1:length(&quot;, vv0[1], &quot;));<Font encoding="UTF-8">\134n&quot;)):</Font>
    end if:
    fprintf(fd, cat(fb2, &quot;tm = toc;<Font encoding="UTF-8">\134n</Font>&quot;)):
    fprintf(fd, cat(fb2, &quot;if isempty(&quot;, vv[1], &quot;); continue; end<Font encoding="UTF-8">\134n</Font>&quot;)):
    fprintf(fd, cat(fb, &quot;catch ME<Font encoding="UTF-8">\134n</Font>&quot;)):
    fprintf(fd, cat(fb2, &quot;continue;<Font encoding="UTF-8">\134n</Font>&quot;)):
    fprintf(fd, cat(fb, &quot;end<Font encoding="UTF-8">\134n\134n</Font>&quot;)):
    fprintf(fd, cat(fb, &quot;M = [];<Font encoding="UTF-8">\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;for j=1:length(&quot;, vv[1], &quot;)<Font encoding="UTF-8">\134n&quot;)):</Font>
    for j from 1 to nops(vars) do
        fprintf(fd, cat(fb2, vars[j], &quot; = &quot;, vv[j], &quot;(j);<Font encoding="UTF-8">\134n&quot;)):</Font>
    end do:
    fprintf(fd, cat(fb2, &quot;m = &quot;, alterComma(convert(U, list)), &quot;;<Font encoding="UTF-8">\134n&quot;)):</Font>
    fprintf(fd, cat(fb2, &quot;m = m/norm(m,'fro');<Font encoding="UTF-8">\134n&quot;)):</Font>
    fprintf(fd, cat(fb2, &quot;M = [M; norm(C*m.','fro')];<Font encoding="UTF-8">\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;end<Font encoding="UTF-8">\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;M = sort(M);<Font encoding="UTF-8">\134n&quot;)):</Font>
    fprintf(fd, cat(fb, &quot;err = norm(M(1:min(&quot;, deg, &quot;,length(M))<Font encoding="UTF-8">),'fro');\134n\134n&quot;)):
</Font>    fprintf(fd, cat(fb, &quot;Err_&quot;, prob, &quot; = [Err_&quot;, prob, &quot; err];<Font encoding="UTF-8">\134n&quot;, fb, &quot;Tm_&quot;, prob, &quot; = [Tm_&quot;, prob, &quot; tm];\134n\134n&quot;)):</Font>
    fprintf(fd, &quot;end<Font encoding="UTF-8">\134n\134n&quot;):</Font>
    fprintf(fd, &quot;folder = fileparts(which('add_all.m'));<Font encoding="UTF-8">\134n&quot;):</Font>
    fprintf(fd, cat(&quot;<Font encoding="UTF-8">save(strcat(folder,'\134\134_results\134\134Err_&quot;, prob, &quot;.mat'),'Err_&quot;, prob, &quot;');\134n\134n&quot;)):
</Font>    fprintf(fd, cat(&quot;<Font encoding="UTF-8">fprintf('Problem: &quot;, prob, &quot;. Ave. runtime: %%0.1f ms. Med. error: %%0.2e\134\134n',10^3*mean(Tm_&quot;, prob, &quot;),median(Err_&quot;, prob, &quot;));\134n&quot;)):</Font>
    fclose(fd):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L5106" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">writeHistoNum := proc(prob::string, root_dir::string)
    local dir := cat(root_dir, &quot;/&quot;, prob), fd, fb := &quot;    &quot;:
    if not FileTools[Exists](dir) then FileTools[MakeDirectory](dir): end if:
    fd := fopen(cat(dir, &quot;/histo_num_&quot;, prob, &quot;.m&quot;), WRITE):
    fprintf(fd, &quot;<Font encoding="UTF-8">folder = fileparts(which('add_all.m'));\134n&quot;):</Font>
    fprintf(fd, cat(&quot;<Font encoding="UTF-8">load(strcat(folder, '\134\134_results\134\134Err_&quot;, prob, &quot;.mat'));\134n\134n&quot;)):</Font>
    fprintf(fd, &quot;<Font encoding="UTF-8">bwd = 0.3;\134n&quot;):
</Font>    fprintf(fd, &quot;nbins = 60;<Font encoding="UTF-8">\134n&quot;):</Font>
    fprintf(fd, &quot;clr = [70 100 160]/255;<Font encoding="UTF-8">\134n&quot;):</Font>
    fprintf(fd, cat(&quot;err = log10(Err_&quot;, prob, &quot;);<Font encoding="UTF-8">\134n&quot;)):</Font>
    fprintf(fd, &quot;hr1 = histogram(err,nbins,'BinWidth',bwd);<Font encoding="UTF-8">\134n&quot;):</Font>
    fprintf(fd, &quot;hr1.FaceColor = clr;<Font encoding="UTF-8">\134n&quot;):</Font>
    fprintf(fd, &quot;hr1.EdgeColor = clr;<Font encoding="UTF-8">\134n\134n&quot;):</Font>
    fprintf(fd, &quot;axis([-17 1 0 1150]);<Font encoding="UTF-8">\134n\134n&quot;):</Font>
    fprintf(fd, &quot;set(gca,'FontSize',54,'FontName','Times New Roman');<Font encoding="UTF-8">\134n&quot;):</Font>
    fprintf(fd, &quot;set(gcf,'PaperPositionMode','auto');<Font encoding="UTF-8">\134n&quot;):</Font>
    fprintf(fd, &quot;set(gcf,'PaperOrientation','landscape');<Font encoding="UTF-8">\134n&quot;):</Font>
    fprintf(fd, &quot;set(gcf,'PaperPosition',[1 1 28 19]);<Font encoding="UTF-8">\134n&quot;):</Font>
    fprintf(fd, cat(&quot;<Font encoding="UTF-8">print(gcf,'-dpdf',strcat(folder,'\134\134_results\134\134fig_&quot;, prob, &quot;.pdf'));</Font>&quot;)):
    fclose(fd):
end proc:</Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L5015" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### Matlab solver generator
solverGenerator := proc(prob::string, {basis::symbol:=std, root_dir::string:=&quot;solvers&quot;, colpiv:=1, create_coefs_file:=1, create_test_file:=1, create_histo_file:=1})
    local vars, av, C, U, E, RB, B, aB, shifts, r2del, c2del, mn, nR, xE, r, rperm, cperm, xV, V, V1, P, aP, nR1, nE1, nB, nP, nE, cp, vars0, iC, eC, M, Mt, iM, eM, dir:
    vars, av, C, U, E, RB, B, aB, shifts, r2del, c2del, mn, nR, xE, r, rperm, cperm, xV := readTemplate(prob, evalb(basis=std)):
    V := &lt;op(E), op(RB)&gt;:
    V1, P, aP, nR1, nE1 := iniColpiv(V, xE, av, vars):
    nB, nP, nE := nops(B), nops(P), nops(E):
    cp := `if`(nP &lt;= nB or colpiv=0, false, true):
    vars0 := `if`(cp, select(vr-&gt;member(vr*P[-1], P[-nB..-1]), vars), select(vr-&gt;member(vr*B[-1], B), vars)):
    <Font encoding="UTF-8">printf(&quot;Variables that can not be evaluated at roots: %a\134n&quot;, [op(convert(vars, set) minus convert(vars0, set))]):</Font>
    iC := [indices(convert(C, table), indexorder)]: # indices of non-zero entries of coefficient matrix C
    eC := map(x-&gt;x[1]+(x[2]-1)*op([1,1], C), iC):
    C := Matrix(op(1, C), {op(zip((x, y)-&gt;(op(x))=y, iC, eC))}):
    M := constructTemplate(shifts, convert(C.U, list), vars, RB)[2]:
    if r&lt;&gt;0 then M := M[rperm, cperm]: end if:
    M := M[remove(`in`, [$ 1..op([1,1], M)], r2del+~r), remove(`in`, [$ 1..op([1,2], M)], c2del+~r)]:
    if cp then M := permuteColumns(M, convert(&lt;op(xV), V&gt;, Vector), convert(&lt;op(xV), V1&gt;, Vector)): end if:
    Mt := convert(M, table):
    iM, eM := [indices(Mt, indexorder)], map(op, [entries(Mt, indexorder)]):
    if not FileTools[Exists](root_dir) then FileTools[MakeDirectory](root_dir): end if:
    dir := cat(root_dir, &quot;/&quot;, prob):
    if not FileTools[Exists](dir) then FileTools[MakeDirectory](dir): end if:
    if cp then
        writeSolverColpiv(dir, [op(1, C)], vars0, av, iM, eM, P, aP, [op(1, M)], nE1, nR1, nB, r, evalb(basis=std)):
    else
        writeSolver(dir, [op(1, C)], vars0, av, iM, eM, B, aB, [op(1, M)], nE, nR, r, evalb(basis=std)):
    end if:
    if create_coefs_file=1 then writeInidataCoefs(prob, root_dir): end if:
    if create_test_file=1 then writeTestNum(prob, nB, mn, vars, vars0, U, basis, root_dir, cp): end if:
    if create_histo_file=1 then writeHistoNum(prob, root_dir): end if:
end proc:</Text-field>
</Input>
</Group></Presentation-Block>
</Section><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L5009" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group view="code" hide-input="false" hide-output="false" labelreference="L5003" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group view="code" hide-input="false" hide-output="false" labelreference="L4999" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4833" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L4456" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L4439" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">save
readProblem,
isLinIndep,
testBasis,
iniMonSet,
neighborMons,
genBasis,
readBases,
basisFinder,
writeGfan,
readGfan,
writeCM,
readCM,
getTord,
readWeights,
writeWeights,
saveData,
readData,
eigenSolver,
srt,
supp,
Supp,
poly2matrix,
permuteColumns,
sparsity,
matrixS,
quotients,
monPartition,
matrixHi,
matrixHni,
syzModule,
matrixHsyz,
fixTemplate,
constructTemplate,
adjustParams,
isActionMatrixFound,
SchurReduction,
linDepReduction,
rectTord,
filterBases,
filterBases2,
iniProb,
templateFinder,
readTemplate,
getB0,
iniColpiv,
alterComma,
writeSolver,
writeSolverColpiv,
writeInidataCoefs,
writeTestNum,
writeHistoNum,
solverGenerator,
&quot;greedyAG.m&quot;:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L4441" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L4440" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-input="false" hide-output="false" labelreference="L4836" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-input="false" hide-output="false" labelreference="L4837" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-input="false" hide-output="false" labelreference="L4838" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4936" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4937" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4938" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4939" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4940" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L5091" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L5097" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group view="presentation" inline-output="false" labelreference="L2" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field style="Text" layout="Normal"><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbWlHRiQ2I1EhRicvJStleGVjdXRhYmxlR1EmZmFsc2VGJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRic=">LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYjLUkjbWlHRiQ2I1EhRic=</Equation></Text-field>
</Input>
</Group></Presentation-Block>
</Worksheet>