opts :=

############################### templateFinder ###############################

# sufficiently large prime number (number of elements in the finite field)
primeNumber = 40009,

# 0/1 - set to 1 for potentially symmetric systems (slower), otherwise set to 0
sym = 0,

# list of positive integers, e.g. [1,2], polynomials from sparsePols must have constant coefficients for all instances
# sparse polynomials can be found automatically if the function for creating polynomials is available in F_prob.m
sparsePols = [],

# list of positive integers, e.g. [1,2], variables from iVars are replaced with their reciprocals in the polynomial system
iVars = [],

# 0/1 - try to remove high-degree polynomials from the initial system w/o changing the ideal
delHardPoly = 0,

# manual list of shifts (it can be copied/pasted from templates/t_prob)
manShifts = [],

# -1/0/1 - shift selection strategy, set to 1 for polynomial systems
sShifts = 1,

# either 1/2/3/4 - action monomial selection strategy, or manual list of action monomials, e.g. [x] or [1/y, z/x]
# 1 - variables only
# 2 - only reciprocals of variables
# 3 - both variables and their reciprocals
# 4 - variables, their reciprocals, and all possible homogeneous monomials of type x/y
sActMons = 3,

# integer >= 0 - change the shift construction function (from shifts() to shifts1()) as d > this value
# set to 100 to use shifts() only (faster but usually larger templates)
# set to 0 to use shifts1() only (slower but usually smaller templates)
dChange = 100,

# 0/1 - try to derive univariate polynomials for each variable in case of positive-dimensional ideal (may be time consuming)
uPoly = 0,

# integer > 0 - maximum number of elimination templates to search
maxTD = 100,

############################### templateReduction ###############################

# 1/2 - template reduction method (1 - better reduction, 2 - faster)
mRed = 1,

# integer >= 0 - allow to increase the number of roots by this value while reduction (applicable to mRed = 1 only)
nRootTol = 0,

# 0/1 - show intermediate data while reduction (0 - faster)
showInfo = 1,

# 0/1 - automatically save intermediate templates to templates/bak_td (useful in case of Maple crashes)
autoBckUp = 1,

############################### solverGenerator ###############################

# root directory for solvers
rootDir = "../solvers",

# 0/1 - show list of permissible monomials (useful for manual reduction)
showPM = 0,

# 0/1 - apply the column-pivoting strategy
colpiv = 0,

# 0/1 - create (if possible) inidata_prob.m and coefs_prob.m for computing initial Macaulay matrix
createCoefsFile = 1,

# 0/1 - create test file test_num_prob.m
createTestFile = 1,

# 0/1 - create solver file red_mxn(_colpiv)_prob.m
createSolverFile = 1,

############################### rootFinder ###############################

# 1/2 - root finding method (1 - elimination template method, 2 - Groebner basis method (applicable to polynomial systems only))
mRoot = 1,

# integer > 0 - number of digits for software floating-point calculations
nDigits = 30,

# 0/1 - show the reduced row echelon form of template (applicable to mRoot = 1 only)
showRREF = 0,

# 0/1 - show the action matrix
showAM = 0,

# 0/1 - show the factorized characteristic polynomial (applicable to mRoot = 1 only) (may be time consuming)
showCP = 0,

# 0/1 - show the action polynomial (applicable to mRoot = 2 only)
showAP = 0: