<?xml version="1.0" encoding="UTF-8"?>
<Worksheet>
<Version major="2016" minor="0"/>
<Label-Scheme value="2" prefix=""/>
<View-Properties presentation="true" autoexpanding_sections="true" UserProfileName="Maple Default Profile" NumericFormat-ApplyInteger="true" NumericFormat-ApplyRational="true" NumericFormat-ApplyExponent="false">
</View-Properties>
<MapleNet-Properties prettyprint="3" warnlevel="3" preplot="" helpbrowser="standard" contextmenusize="automatic" displayprecision="-1" echo="1" unitattributes="&quot;fontweight&quot; = &quot;bold&quot;" imaginaryunit="I" longdelim="true" elisiontermsthreshold="10000" elisiondigitsafter="100" elisiondigitsbefore="100" plotdevice="inline" errorbreak="1" plotoptions="" plotdriver="opengl" quiet="false" elisiontermsbefore="100" elisiontermsafter="100" screenwidth="79" indentamount="4" plotoutput="terminal" screenpixelheight="768" rtablesize="10" useclientjvm="true" labelwidth="20" postplot="" typesetting="standard" ansi="false" elisiondigitsthreshold="10000" showassumed="1" errorcursor="false" labelling="true" screenheight="25" prompt="&gt; " verboseproc="1" latexwidth="8.0" ShowLabels="false"/>
<Styles>
<Font name="Heading 1" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Warning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Line Printed Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 2" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="16" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Output" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Inert Output" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[144,144,144]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Heading 3" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="true" opaque="false" readonly="false" size="14" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Diagnostic" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[40,120,40]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 1" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[120,0,14]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text Output" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 2" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 3" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 4" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Ordered List 5" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Header and Footer" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="10" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkError" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Atomic Variable" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[175,0,175]" italic="true" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="HyperlinkWarning" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[0,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Dictionary Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[147,0,15]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="2D Math" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Bullet Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Plot" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Annotation Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="List Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Dash Item" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="2D Input" background="[255,255,255]" bold="false" executable="true" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Error" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,255]" italic="false" opaque="false" readonly="true" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Title" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="18" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Text" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Normal" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Caption Reference" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Code" background="[255,255,255]" bold="false" executable="false" family="Courier New" foreground="[255,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Maple Input Placeholder" background="[255,255,255]" bold="true" executable="true" family="Courier New" foreground="[200,0,200]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="true"/>
<Font name="Equation Label" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Author" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Font name="Hyperlink" background="[255,255,255]" bold="false" executable="false" family="Times New Roman" foreground="[0,128,128]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="true" placeholder="false"/>
<Font name="Caption Text" background="[255,255,255]" bold="true" executable="false" family="Times New Roman" foreground="[0,0,0]" italic="false" opaque="false" readonly="false" size="12" subscript="false" superscript="false" underline="false" placeholder="false"/>
<Layout name="Heading 1" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="4" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Warning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 4" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Line Printed Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 2" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="2" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Output" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.3" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Heading 3" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Diagnostic" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="any" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 1" alignment="left" bullet="numeric" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Text Output" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="newline" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Ordered List 2" alignment="left" bullet="alphabetic" firstindent="0" leftmargin="36" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 3" alignment="left" bullet="roman" firstindent="0" leftmargin="72" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 4" alignment="left" bullet="ALPHABETIC" firstindent="0" leftmargin="108" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Ordered List 5" alignment="left" bullet="ROMAN" firstindent="0" leftmargin="144" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="-1" bulletsuffix="."/>
<Layout name="Annotation Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkError" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="HyperlinkWarning" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Bullet Item" alignment="left" bullet="dot" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Maple Plot" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="List Item" alignment="left" bullet="indent" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Dash Item" alignment="left" bullet="dash" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="3" spacebelow="3" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Error" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Title" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="12" spacebelow="12" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Normal" alignment="left" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="0" spacebelow="0" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Layout name="Author" alignment="centred" bullet="none" firstindent="0" leftmargin="0" rightmargin="0" linespacing="0.0" spaceabove="8" spacebelow="8" linebreak="space" pagebreak-before="false" initial="0" bulletsuffix=""/>
<Pencil-style name="Pencil 1" pen-color="[0,0,0]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 2" pen-color="[0,0,255]" pen-height="1.0" pen-width="1.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 3" pen-color="[0,0,0]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 4" pen-color="[0,0,255]" pen-height="3.0" pen-width="3.0" pen-opacity="1.0"/>
<Pencil-style name="Pencil 5" pen-color="[255,0,0]" pen-height="5.0" pen-width="5.0" pen-opacity="1.0"/>
<Highlighter-style name="Highlighter 5" pen-color="[255,255,0]" pen-height="48.0" pen-width="48.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 3" pen-color="[51,255,0]" pen-height="24.0" pen-width="24.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 4" pen-color="[0,255,255]" pen-height="32.0" pen-width="32.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 1" pen-color="[255,153,255]" pen-height="12.0" pen-width="8.0" pen-opacity="0.8"/>
<Highlighter-style name="Highlighter 2" pen-color="[255,204,0]" pen-height="14.0" pen-width="14.0" pen-opacity="0.8"/>
</Styles>
<Startup-Code startupcode=""/>
<Task-table>
    <Task-category name="&lt;default&gt;"/>
</Task-table>
<Task/><Presentation-Block>
<Group hide-output="false" labelreference="L4443" drawlabel="true">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">restart:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4464" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-input="false" hide-output="false" labelreference="L4466" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4835" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### find monomial ordering which is compatible with a given Grobner basis and leading monomial
### in case of error, try to increase depthlimit option
getTord := proc(gb, lm)
    local vars := [op(indets(gb))], nv := nops(vars), sbt := [0 $ nv]=NULL, degs := [seq(d||i, i=1..nv)], gbdegs, lmdegs, ineqs, sol, fdegs:
    gbdegs := map(z-&gt;map(x-&gt;[seq(degree(x, y), y in vars)], convert(z, list)), gb):
    lmdegs := map(x-&gt;[seq(degree(x, y), y in vars)], lm):
    ineqs := map(k-&gt;op(map(x-&gt;add(zip((y, z)-&gt;y*z, x, degs)) &gt;= 1, subs(sbt, [seq(lmdegs[k] - g, g in gbdegs[k])]))), {$ 1..nops(gb)}):
    sol := Optimization[Minimize](add(degs), ineqs, <Font opaque="false" subscript="false" underline="false" superscript="false" bold="true" foreground="[120,0,14]" italic="false" executable="true" selection-placeholder="false" size="12" readonly="false" background="[255,255,255]" style="Help Maple Name" placeholder="false" family="Courier New" font_style_name="Help Maple Name">depthlimit=35</Font>, assume=nonnegint)[2]:
    fdegs := subs(sol, degs):
    fdegs, <Font opaque="false" subscript="false" underline="false" superscript="false" bold="true" foreground="[120,0,14]" italic="false" executable="true" selection-placeholder="false" size="12" readonly="false" background="[255,255,255]" style="Help Maple Name" placeholder="false" family="Courier New" font_style_name="Help Maple Name">wdeg(</Font>fdegs<Font opaque="false" subscript="false" underline="false" superscript="false" bold="true" foreground="[120,0,14]" italic="false" executable="true" selection-placeholder="false" size="12" readonly="false" background="[255,255,255]" style="Help Maple Name" placeholder="false" family="Courier New" font_style_name="Help Maple Name">, vars):</Font>
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4831" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">readCM := proc(prob::string, px::string, opt:=false, std:=true)
    local st := 1, cmfile, pp, vars, m := 0, n := 0:
    cmfile := ifelse(std, ifelse(opt, cat(px, &quot;optim/cm/cm_&quot;, prob, &quot;.txt&quot;), cat(px, &quot;cm/cm_&quot;, prob, &quot;.txt&quot;)), cat(px, &quot;cm/nstd/cm_&quot;, prob, &quot;.txt&quot;)):
    pp := parse(readline(cmfile)): # read prime number
    vars := parse(readline(cmfile)): # read variables
    while st &lt;&gt; 0 do
        st := readline(cmfile):
        if st &lt;&gt; 0 and substring(st, 1) = &quot;(&quot; then
            m := m + 1:
            T||m := substring(st, 2..-2):
        elif st &lt;&gt; 0 and substring(st, 1..6) = &quot;matrix&quot; then
            n := n + 1:
            CM||n := StringTools[SubstituteAll](StringTools[SubstituteAll](substring(st, 9..-2), &quot;{&quot;, &quot;[&quot;), &quot;}&quot;, &quot;]&quot;):
        end if:
    end do:
    return pp, [seq(wdeg([parse(T||i)], vars), i=1..m)], [seq(Matrix([map(parse, CM||i)])^%T, i=1..n)]:
end proc:</Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L4810" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">readNonGB := proc(prob::string, px::string)
    local st := 1, QBs := [], nongbfile := cat(px, &quot;nongb/nongb_&quot;, prob, &quot;.txt&quot;):
    while st &lt;&gt; 0 do
        st := readline(nongbfile):
        if st &lt;&gt; 0 then QBs := [op(QBs), parse(st)]: end if:
    end do:
    QBs:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4829" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">saveData := proc(prob::string, px::string, mn, sp, pp, vars, av, tord, QB, mon, qb)
    local fd, mnsp0, mn0, sp0, datafile := ifelse(qb=2, cat(px, &quot;optim/O_nstd_&quot;, prob, &quot;.txt&quot;), cat(px, &quot;optim/O_std_&quot;, prob, &quot;.txt&quot;)), flag := false:
    if FileTools[Exists](datafile) then
        fd := fopen(datafile, READ):
        mnsp0 := parse(readline(datafile)):
        if nops([mnsp0]) = 2 then mn0, sp0 := mnsp0: else mn0 := mnsp0: sp0 := -1: end if:
        if mn[1] &lt; mn0[1] or (mn[1] = mn0[1] and sp &gt; sp0) then flag := true: end if:
        fclose(fd):
    else
        flag := true:
    end if:
    if flag then
        fd := fopen(datafile, WRITE):
        <Font encoding="UTF-8">fprintf(fd, &quot;%a,%a\134n%a\134n%a\134n%a\134n%a\134n%a\134n%a&quot;, mn, sp, pp</Font>, convert(vars, list), av, tord, QB, mon):
        fclose(fd):
    end if:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4830" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">readData := proc(prob::string, px::string, std)
    local datafile, mnsp, mn, sp, pp, vars, av, tord, QB, mon:
    datafile := ifelse(std, cat(px, &quot;optim/O_std_&quot;, prob, &quot;.txt&quot;), cat(px, &quot;optim/O_nstd_&quot;, prob, &quot;.txt&quot;)):
    mnsp := parse(readline(datafile)):
    if nops([mnsp]) = 2 then mn, sp := mnsp: else mn := mnsp: sp := -1: end if:
    pp := parse(readline(datafile)):
    vars := parse(readline(datafile)):
    av := parse(readline(datafile)):
    tord := parse(readline(datafile)):
    QB := parse(readline(datafile)):
    mon := parse(readline(datafile)):
    readline(datafile): ### = 0
    mn, sp, pp, vars, av, tord, QB, map(eval, mon):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-input="false" hide-output="false" labelreference="L4809" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group hide-output="false" labelreference="L4438" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">srt := (v, tord)-&gt;sort(v, (x, y)-&gt;Groebner[TestOrder](y, x, tord)):</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L4449" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### transform list of polynomials into coefficient matrix and monomial vector
poly2matrix := proc(F, nF, vars)
    local cffs := [coeffs(expand(add(q_q||i*F[i], i=1..nF)), vars, 'mons')]:
    Matrix(nF, nops(cffs), (i, j)-&gt;coeff(cffs[j], q_q||i)), Vector([mons]):
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L4432" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### permute columns of square matrix M
permuteColumns := proc(M::Matrix, V1::Vector, V2::Vector)
    local n := op(1, V1):
    M.Matrix(n, {seq((i, ListTools[Search](V1[i], V2)) = 1, i=1..n)}):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4843" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### compute sparsity of matrix M
getSparsity := proc(M)
    local numzr := nops(select(x-&gt;is(x=0), convert(M, list))):
    numzr/mul(op(1, M)):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4548" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### compute change-of-basis matrix S
getMatrixS := proc(B::list, B0::list, Gr, tord, pp::nonnegint)
    local S, V0, deg := nops(B):
    if nops(B0) &lt;&gt; deg then error(`Lists B0 and B must have the same length`): end if:
    S, V0 := poly2matrix(map(b-&gt;Groebner[NormalForm](b, Gr, tord, characteristic=pp), B), deg, indets(Gr)):
    if op(1, V0) = deg then
        return permuteColumns(S, V0, Vector(B0)):
    else # should never get here
        error(`Failed to construct matrix S`):
    end if:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4834" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">getQuotients := proc(g, Gr, tord, pp) Groebner[NormalForm](g, Gr, tord, 'Q', characteristic=pp): Q: end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L4446" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">getPartition := proc(av, Gr::list, tord, pp::nonnegint, QB::list:=[])
    local B0, B, aB, R, B2, RB, G, nG, T, S, i:
    B0 := Groebner[NormalSet](Gr, tord)[1]:
    B := convert(ifelse(QB = [], B0, QB), set):
    aB := map(x-&gt;x*av, B):
    R := srt(convert(aB minus B, list), tord):
    nG := nops(R):
    B2 := map(x-&gt;x/av, aB intersect B):
    B := [op(srt(convert(B minus B2, list), tord)), op(srt(convert(B2, list), tord))]:
    RB, aB := [op(R), op(B)], map(x-&gt;x*av, B):
    if QB = [] then
        T := Groebner[MultiplicationMatrix](av, B, table(Equate(B, [$ 1..nops(B)])), Gr, tord, characteristic=pp):
    else
        T := Groebner[MultiplicationMatrix](av, B0, table(Equate(B0, [$ 1..nops(B0)])), Gr, tord, characteristic=pp):
        S := getMatrixS(B, B0, Gr, tord, pp):
        T := S.T.LinearAlgebra[Modular][Inverse](pp, S) mod pp: # new action matrix
    end if:
    G := convert(Vector(R) - T[[1..nG], ..].Vector(B), list):
    return aB, B, RB, T, G, Matrix([seq(getQuotients(G[i], Gr, tord, pp), i=1..nG)]):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4844" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### solve linear equations over a finite field
lsolve := proc(leqs::list, pp::nonnegint, z::name)
    local lvars := [op(indets(leqs))], A, b, sol:
    A := &lt;seq(&lt;seq(coeff(le, lv), lv in lvars)&gt;^%T, le in leqs)&gt;:
    b := A.Vector(lvars) - Vector(leqs):
    sol := Linsolve(A, b, 'r', z) mod pp:
    if type(sol, function) then return []: end if: ### no solution exists
    [seq(lvars[k]=sol[k], k=1..nops(lvars))]:
end proc:</Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L4771" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### construct polynomial of a given degree with undetermined coefficients
undetPoly := proc(vars, pv, d, j)
    local mons:
    coeffs(expand(1 + add(pv^p, p=1..d)), vars, 'mons'):
    mons := [mons]:
    add(mons[k]*_v[j, k], k=1..nops(mons)):
end proc:</Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group view="code" hide-output="false" labelreference="L4536" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### iteratively construct matrix H of size nG x nF
getMatrixH := proc(F::list, G::list, vars::set, pp::nonnegint, dom::nonnegint:=0)
    local pv := add(vars), nF := nops(F), nG := nops(G), uH, sol, i, dF := map(degree, F, vars), dG, d, d_min, h:
    for i from 1 to nG do
        d_min, dG := 0, map(x-&gt;max(0, x), [degree(G[i], vars) $ nF] - dF):
        for d from 0 while d - d_min &lt;= dom do
            uH := [seq(undetPoly(vars, pv, dG[j] + d, j), j=1..nF)]:
            sol := msolve({coeffs(expand(-G[i] + add(uH[j]*F[j], j=1..nF)), vars)}, pp):
            if nops({sol}) = 0 then d_min := d + 1: end if:
        end do:
        h[i] := map(expand@eval, uH, sol) mod pp:
    end do:
    &lt;seq(Vector[row](h[i]), i=1..nG)&gt;:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4805" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">undetPolyni := proc(h, vars, i, j)
    local mons:
    coeffs(h, vars, 'mons'):
    mons := [mons]:
    add(mons[k]*_v[i, j, k], k=1..nops(mons)):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4790" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### use known change matrix to non-iteratively construct matrix H of size nG x nF
getMatrixHni := proc(F::list, G::list, C::Matrix, CM::Matrix, vars::set, pp::nonnegint)
    local nF := nops(F), nG := nops(G), H0, uH, sol, pars:
    H0 := map(expand, C.CM) mod pp:
    uH := Matrix(nG, nF, (i, j)-&gt;undetPolyni(H0[i, j], vars, i, j)):
    pars := {seq(_u[i], i=1..nops(indets(uH) minus vars))}:
    sol := msolve(map(coeffs, {seq(expand(-G[i] + add(uH[i, j]*F[j], j=1..nF)) mod pp, i=1..nG)}, vars), pars, pp):
    map(expand@eval, uH, sol) mod pp:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4811" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### find set of monomials of polynomial h
getMons := proc(h, vars) coeffs(h, vars, 'mons'): {mons}: end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4812" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### fix incomplete template by adding more rows and columns
corTemplate := proc(admons, F, vars, mon, RB)
    local nF := nops(F), monF := map(f-&gt;getMons(f, vars), F), admon := [{} $ nF], i, j, Q, flag, expF, M, V0, E, V, mon1:
    for i from 1 to nops(admons) do
        flag := false:
        for j from 1 to nops(F) do
            Q := map(mf-&gt;ifelse(divide(admons[i], mf, 'q'), q, NULL), monF[j]):
            if Q &lt;&gt; {} then admon[j] := {op(admon[j]), Q[1]}: flag := true: break: end if:
        end do:
        if not flag then error(`Failed to correct template`): end if: # never get here
    end do:
    mon1 := [seq(convert(convert(mon[j], set) union admon[j], Vector), j=1..nF)]:
    expF := [seq(seq(F[j]*mn, mn in mon1[j]), j=1..nF)]:
    M, V0 := poly2matrix(expF, nops(expF), vars):
    E := convert(V0, set) minus convert(RB, set):
    V := &lt;op(E), op(RB)&gt;:
    print(`Template corrected`):
    return mon1, M, V0, V:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4827" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### construct elimination template either from matrix H or from a list of expansion monomials
constructTemplate := proc(H, F, vars, RB)
    local nF := nops(F), mon, expF, M, V0, E, V:
    mon := ifelse(type(H, Matrix), [seq(poly2matrix(H[.., j], op([1, 1], H), vars)[2], j=1..nF)], H):
    expF := [seq(seq(F[j]*mn, mn in mon[j]), j=1..nF)]: # expanded polynomial system
    M, V0 := poly2matrix(expF, nops(expF), vars): # matrix form of expF, M.V0 = vec(expF)
    E := convert(V0, set) minus convert(RB, set): # set of excessive monomials
    V := &lt;op(E), op(RB)&gt;: # vector of all monomials
    if op(1, V) &lt;&gt; op(1, V0) then # template is incomplete
        print(`Template is incomplete`):
        mon, M, V0, V := corTemplate(convert(V, set) minus convert(V0, set), F, vars, mon, RB):
    end if:
    mon, permuteColumns(M, V0, V): # reorder columns of M w.r.t. permutation from V0 to V
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L4444" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### adjust parameters
adjustParams := proc(F::list, H::Matrix, RB::list, vars::set, pp::nonnegint)
    local nF := nops(F), nG := op([1, 1], H), H1 := H, Lm, cols, L, mon, V0, E, e, sm, rm, np, ss, prm, leqs, sol:

    Lm := seq(poly2matrix(H[.., j], nG, vars), j=1..nF):
    cols := [seq(remove(x-&gt;membertype(posint, convert(Lm[2*j-1][.., x], list)), [$ 1..op([1, 2], Lm[2*j-1])]), j=1..nF)]:
    L, mon := [seq(Lm[2*j-1][.., cols[j]], j=1..nF)], [seq(Lm[2*j][cols[j]], j=1..nF)]:
    sm := [seq(map(t-&gt;getMons(expand(F[j]*t), vars), mon[j]), j=1..nF)]:
    V0 := convert(map(op, map(op@convert, sm, set)), set): # set of all monomials in the expanded system
    E := convert(V0 minus convert(RB, set), list): # list of excessive monomials
    sm := Vector(sm):
    rm := map(e-&gt;select(i-&gt;member(e, sm[i]), {$ 1..op(1, sm)}), E):
    np := [seq(`+`(seq(nops(select(has, rm, rm[j][i])), i=1..nops(rm[j]))), j=1..nops(rm))]:
    ss := (i, j, rm, np)-&gt;(nops(rm[i]) &gt; nops(rm[j])) or (nops(rm[i]) = nops(rm[j]) and np[i] &gt; np[j]):
    #ss := (i, j, rm, E)-&gt;(nops(rm[i]) &gt; nops(rm[j])) or (nops(rm[i]) = nops(rm[j]) and degree(E[i]) &gt; degree(E[j])):

    ### reorder excessive monomials so that first are monomials requiring setup of smaller number of parameters
    #rm := map(e-&gt;map(x-&gt;{ListTools[SearchAll](1, map(y-&gt;nops(y intersect {e}), x))}, sm), E):
    prm := sort([$ 1..nops(E)], (i, j)-&gt;ss(i, j, rm, np)):
    E := E[prm]: # sorted list of excessive monomials

    ### start adjusting parameters
    for e in E do
        Lm := seq(poly2matrix(H1[.., j], nG, vars), j=1..nF):
        L, mon := [seq(Lm[2*j-1], j=1..nF)], [seq(Lm[2*j], j=1..nF)]:
        if nops(indets(L)) = 0 then break: end if: # nothing to adjust
        sm := [seq(map(t-&gt;getMons(expand(F[j]*t), vars), mon[j]), j=1..nF)]:
        rm := map(x-&gt;{ListTools[SearchAll](1, map(y-&gt;nops(y intersect {e}), x))}, sm):
        leqs := {seq(op(map(k-&gt;op(convert(L[j][.., k], set)), rm[j])), j=1..nF)}:
        sol := msolve(leqs, pp):
        if nops({sol}) = 0 then next: end if:
        H1 := map(expand@eval, H1, sol) mod pp:
    end do:

    constructTemplate(H1, F, vars, RB):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4919" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4924" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### adjust parameters (strategy S2)
adjustParamsS2 := proc(F::list, H::Matrix, RB::list, vars::set, pp::nonnegint)
    local nF := nops(F), H1 := H, nG := op([1, 1], H), Lm, L, mon, cols, m, pars, L1, tL1, basis, T, T1, cf, tord := tdeg(op(vars)), b, prm, i, sol:

    Lm := seq(poly2matrix(H[.., j], nG, vars), j=1..nF):
    L, mon := Matrix([seq(Lm[2*j-1], j=1..nF)]), Vector([seq(Lm[2*j], j=1..nF)]):
    cols := remove(j-&gt;membertype(posint, convert(L[.., j], list)), [$ 1..op([1, 2], L)]):
    L, mon := L[remove(i-&gt;ArrayTools[IsZero](L[i, cols]), [$ 1..nG]), cols], mon[cols]:
    m, pars := op([1, 2], L), indets(L):
    cf := map(j-&gt;nops(select(x-&gt;is(x=0), convert(L[.., j], list))), [$ 1..m]):
    prm := sort([$ 1..m], (x, y) -&gt; (cf[x] &gt; cf[y]) or (cf[x] = cf[y] and Groebner[TestOrder](mon[y], mon[x], tord)), 'output=permutation'):
    L := L[.., prm]:
    L1 := &lt;seq(poly2matrix(convert(L[j, ..], list), m, pars)[1]^%T, j=1..op([1, 1], L))&gt;:
    tL1 := Gaussjord(L1, 'r') mod pp:
    basis := [seq(ListTools[Search](1, convert(tL1[j, ..], list)), j=1..r)]:
    T := [seq(select(j-&gt;ArrayTools[HasNonZero](tL1[j, k]), [$ 1..r]), k=1..m)]:
    T1 := [seq(map(y-&gt;basis[y], {op(T[j])}), j=1..m)]:
    cf := map(y-&gt;add(map(z-&gt;1/nops(z), select(x-&gt;`subset`({y}, x), T1))), basis):
    b := sort(cf, (x, y) -&gt; x &gt; y, 'output=permutation'):
    prm := [op(basis[b]), op({$ 1..m} minus {op(basis)})]:

    ### start adjusting parameters
    for i from 1 to m do
        if nops(indets(L)) = 0 then break: end if: # nothing to adjust
        sol := lsolve(convert(L[.., prm[i]], list), pp, _t||i):
        if nops(sol) = 0 then next: end if:
        H1 := map(expand@eval, H1, sol) mod pp:
        L := map(expand@eval, L, sol) mod pp:
    end do:

    constructTemplate(H1, F, vars, RB):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" labelreference="L4925" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4922" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">adjustParamsS41 := proc(F::list, H::Matrix, RB::list, vars::set, pp::nonnegint)
    local nF := nops(F), nG := op([1, 1], H), H1 := H, Lm, cols, L, mon, sm, m, V0, E, e, rm, ss, prm, leqs, sol:

    Lm := seq(poly2matrix(H[.., j], nG, vars), j=1..nF):
    cols := [seq(remove(x-&gt;membertype(posint, convert(Lm[2*j-1][.., x], list)), [$ 1..op([1, 2], Lm[2*j-1])]), j=1..nF)]:
    L, mon := Matrix([seq(Lm[2*j-1][.., cols[j]], j=1..nF)]), [seq(Lm[2*j][cols[j]], j=1..nF)]:
    L := L[remove(i-&gt;ArrayTools[IsZero](L[i, ..]), [$ 1..nG]), ..]:
    sm := Vector([seq(map(t-&gt;getMons(expand(F[j]*t), vars), mon[j]), j=1..nF)]):
    m := op(1, sm):
    V0 := `union`(seq(sm)): # set of all monomials in the expanded system
    E := convert(V0 minus convert(RB, set), list): # list of excessive monomials
    rm := map(e-&gt;select(j-&gt;member(e, sm[j]), [$ 1..m]), E):
    ss := (i, j, rm, E)-&gt;(degree(E[i]) &gt; degree(E[j])) or (degree(E[i]) = degree(E[j]) and nops(rm[i]) &gt; nops(rm[j])):
    prm := sort([$ 1..nops(E)], (i, j)-&gt;ss(i, j, rm, E)):
    E := E[prm]: # sorted list of excessive monomials

    ### start adjusting parameters
    for e in E do
        if nops(indets(L)) = 0 then break: end if: # nothing to adjust
        leqs := convert(L[.., select(j-&gt;member(e, sm[j]), [$ 1..m])], set):
        if membertype(posint, leqs) then next: end if: # system is inconsistent
        sol := msolve(leqs, pp):
        if nops({sol}) = 0 then next: end if:
        H1 := map(expand@eval, H1, sol) mod pp:
        Lm := seq(poly2matrix(H1[.., j], nG, vars), j=1..nF):
        cols := [seq(remove(x-&gt;membertype(posint, convert(Lm[2*j-1][.., x], list)), [$ 1..op([1, 2], Lm[2*j-1])]), j=1..nF)]:
        L, mon := Matrix([seq(Lm[2*j-1][.., cols[j]], j=1..nF)]), [seq(Lm[2*j][cols[j]], j=1..nF)]:
        L := L[remove(i-&gt;ArrayTools[IsZero](L[i, ..]), [$ 1..nG]), ..]:
        sm := Vector([seq(map(t-&gt;getMons(expand(F[j]*t), vars), mon[j]), j=1..nF)]):
        m := op(1, sm):
    end do:

    constructTemplate(H1, F, vars, RB):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" labelreference="L4923" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group view="presentation" inline-output="false" labelreference="L4926" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field style="Text" layout="Normal"><Equation executable="true" style="2D Math" input-equation="" display="LUklbXJvd0c2Iy9JK21vZHVsZW5hbWVHNiJJLFR5cGVzZXR0aW5nR0koX3N5c2xpYkdGJzYlLUkjbWlHRiQ2I1EhRicvJStleGVjdXRhYmxlR1EmZmFsc2VGJy8lLG1hdGh2YXJpYW50R1Enbm9ybWFsRic=">JSFH</Equation></Text-field>
</Input>
</Group></Presentation-Block><Presentation-Block>
<Group hide-output="false" labelreference="L4433" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### check if the action matrix is found
isActionMatrixFound := proc(T::Matrix, M::Matrix, aB::list, B::list, nG::posint, pp::nonnegint)
    local tM, T1, deg := nops(B), m := deg - nG, r:
    tM := Gaussjord(M, 'r') mod pp: # r is for rank
    T1 := &lt;-tM[[r-nG+1..r], [-deg..-1]], Matrix(m, deg, {seq((m-k+1, ListTools[Search](aB[-k], B)) = 1, k=1..m)})&gt; mod pp:
    LinearAlgebra[Equal](T, T1):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4825" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">reduceKnownPivots := proc(mon, M, nE, ps::list, pp::nonnegint)
    local rg, crg, m, M1, bs, M2, tM2, M3, tM3, M4, basis, lindep, B1, B2, B3, B4, iB1:
    rg := [seq(op([$ add(op(1, mon[i]), i=1..p-1)+1..add(op(1, mon[i]), i=1..p)]), p in ps)]:
    m := nops(rg):
    crg := [op({$ 1..op([1, 1], M)} minus {op(rg)})]:
    M1 := &lt;M[rg, ..], M[crg, ..]&gt;:
    M2 := M1[1..m, 1..nE]:
    tM2 := Gaussjord(M2^%T, 'r') mod pp:
    basis := map(i-&gt;ListTools[Search](1, convert(tM2[i], list)), {$ 1..r}):
    lindep := convert({$ 1..op([1, 2], tM2)} minus basis, list):
    M3 := &lt;M1[[op(basis)], ..], M1[[op(lindep)], ..], M1[m+1..-1, ..]&gt;:
    tM3 := Gaussjord(M3[1..m, 1..nE], 'r') mod pp:
    basis := map(i-&gt;ListTools[Search](1, convert(tM3[i], list)), {$ 1..r}):
    lindep := convert({$ 1..op([1, 2], tM3)} minus basis, list):
    M4 := &lt;M3[.., [op(basis)]]|M3[.., [op(lindep)]]|M3[.., nE+1..-1]&gt;:
    B1, B2, B3, B4 := M4[[1..r], [1..r]], M4[[1..r], [r+1..-1]], M4[[r+1..-1], [1..r]], M4[[r+1..-1], [r+1..-1]]:
    iB1 := Inverse(B1) mod pp:
    B4 - B3.iB1.B2 mod pp:
end proc:</Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L4450" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### remove linearly dependent rows and columns from the template
reduceLinDep := proc(M::Matrix, pp::nonnegint)
    local r, tM, M1, tM1, basis, r2del, c2del:
    ### remove linearly dependent rows
    tM := Gaussjord(M^%T, 'r') mod pp:
    basis := map(i-&gt;ListTools[Search](1, convert(tM[i], list)), {$ 1..r}):
    r2del := convert({$ 1..op([1, 2], tM)} minus basis, list):
    M1 := M[remove(i-&gt;is(i in r2del), [$ 1..op([1, 1], M)]), ..]:
    ### remove linearly dependent columns
    tM1 := Gaussjord(M1, 'r') mod pp:
    basis := map(i-&gt;ListTools[Search](1, convert(tM1[i], list)), {$ 1..r}):
    c2del := convert({$ 1..max(basis)} minus basis, list):
    M1[.., remove(i-&gt;is(i in c2del), [$ 1..op([1, 2], M1)])], r2del, c2del:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4821" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### rectify monomial ordering using heuristics
rectTord := proc(F, vars::list, Ts, pp::nonnegint)
    local nF := nops(F), dg, wt, nn, GBs, Ws:
    dg := [seq(add(map(degree, F, vr))/nF, vr in vars)]:
    wt := map(d-&gt;1/d, dg):
    nn := lcm(op(map(denom, wt))):
    wt := nn*wt:
    GBs := map(x-&gt;Groebner[Basis](F, x, characteristic=pp), Ts):
    Ws := [op({seq(getTord(GBs[i], Groebner[LeadingMonomial](GBs[i], Ts[i]))[1], i=1..nops(GBs))})]:
    Ws := map(z-&gt;zip((x, y)-&gt;x*y, z, wt), Ws):
    map(x-&gt;wdeg(x, vars), Ws):
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4546" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### filter out some quotient space bases
QBfilter := proc(F::list, QBs::list, nQBs::posint, ff)
    local mF, Bs, prm, n := round(ff*nQBs):
    mF := convert(poly2matrix(F, nops(F), indets(F))[2], set): # set of all monomials in F
    Bs := map(x-&gt;nops(convert(x, set) intersect mF), QBs):
    prm := sort(Bs, `&gt;`, output=permutation):
    print(cat(n, ` quotient space bases removed`)):
    [op(1..nQBs-n, prm)]:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4537" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### initialize minimal problem
iniProb := proc(prob::string, px::string, qb, ff)
    local F, vF, pp, vars, GBs, Ts, GC, QBs, CMs, tord, CM, Gr, q, nQBs:
    read cat(px, &quot;problems/F_&quot;, prob, &quot;.m&quot;):
    F, pp := eval(cat(F_, prob)), 32749: # sufficiently large prime number (32749 is maximal prime number for Gfan&quot;)
    vF := Vector(F):
    if Groebner[HilbertDimension](F, characteristic=pp) &lt;&gt; 0 then error(&quot;The problem is expected to have infinitely many solutions&quot;): end if:
    vars := indets(F):
    if qb = 1 then # use Grobner fan or a part of it
        pp, Ts, CMs := readCM(prob, px): # read change matrices and monomial orderings
        nQBs := nops(CMs):
        print(cat(nQBs, ` change matrices loaded`)):
        GBs := [seq(map(expand, convert(CMs[i].vF, list)) mod pp, i=1..nQBs)]:
        QBs := [seq(Groebner[NormalSet](GBs[i], Ts[i])[1], i=1..nQBs)]: # compute quotient space bases
        q := QBfilter(F, QBs, nQBs, ff):
        CMs, GBs, Ts, QBs := [seq(CMs[i], i in q)], [seq(GBs[i], i in q)], [seq(Ts[i], i in q)], [seq(QBs[i], i in q)]:
    elif qb = 2 then # use non-standard bases for the quotient ring
        QBs := readNonGB(prob, px):
        nQBs := nops(QBs):
        pp, Ts, CMs := readCM(prob, px, false, false):
        print(cat(nQBs, ` quotient space bases loaded`)):
        tord, CM := Ts[1], CMs[1]:
        Gr := map(expand, convert(CM.vF, list)) mod pp:
        q := QBfilter(F, QBs, nQBs, ff):
        CMs, GBs, Ts, QBs := [seq(CM, i in q)], [seq(Gr, i in q)], [seq(tord, i in q)], [seq(QBs[i], i in q)]:
    else # qb = 0
        Ts := map(x-&gt;tdeg(op(x)), combinat[permute](vars)):
        Ts := rectTord(F, [op(vars)], Ts, pp):
        GC := map(x-&gt;[Groebner[Basis](F, x, characteristic=pp, output=extended)], Ts): # compute Grobner bases and change matrices
        GBs, CMs := map(x-&gt;x[1], GC), map(x-&gt;Matrix(x[2]), GC):
        nQBs := nops(GBs):
        QBs := [seq(convert(Groebner[NormalSet](GBs[i], Ts[i])[1], set), i=1..nQBs)]:
        q := {seq(ListTools[Search](QBs[i], QBs), i=1..nQBs)}: # remove repeated bases
        CMs, GBs, Ts, QBs := [seq(CMs[i], i in q)], [seq(GBs[i], i in q)], [seq(Ts[i], i in q)], [seq(QBs[i], i in q)]:
        print(cat(nops(QBs), ` quotient space bases computed (`, nQBs, `)`)):
    end if:
    print(cat(`The problem is expected to have `, nops(QBs[1]), ` solutions`)):
    return pp, F, vars, GBs, Ts, QBs, CMs:
end proc:</Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4461" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">### automatic template generator for a given minimal problem
genTemplate := proc(prob::string, params::list)
    local F, pp, qb, dom, av, ff, px, ps, vars, avars, GBs, Ts, QBs, CMs, Gr, tord, i, j, k, H, mon, M, aB, B, RB, T, G, C, fl, m, n, mo := 10^6, no, sp, spo := -1, N, nv, nG, deg, db, q, irng, nk, QB, tord1:
    qb, dom, av, ff, px, ps, db := op(params):
    pp, F, vars, GBs, Ts, QBs, CMs := iniProb(prob, px, qb, ff):
    avars := ifelse(nops(av)=0, vars, map(a-&gt;vars[a], av)):
    q := iquo(nops(QBs), db[1]):
    irng := [$ 1+(db[2]-1)*q..ifelse(db[2]=db[1], nops(QBs), db[2]*q)]:
    nv, deg, nk := nops(avars), nops(QBs[1]), nops(irng):
    N := 100/(nk*nv):
    for k from 1 to nk do
        i := irng[k]:
        Gr, tord, QB := GBs[i], Ts[i], QBs[i]:
        tord1 := ifelse(op(2, tord)=[op(vars)], op(1, tord), tord):
        for j from 1 to nv do
            aB, B, RB, T, G, C := getPartition(avars[j], Gr, tord, pp, QB):
            nG := nops(G):
            H := ifelse(qb = 2, getMatrixH(F, G, vars, pp), getMatrixHni(F, G, C, CMs[i], vars, pp)):
            mon, M := adjustParams(F, H, RB, vars, pp): # adjust parameters and return template M
            if ps &lt;&gt; [] then M := reduceKnownPivots(mon, M, op([1, 2], M)-deg-nG, ps, pp): end if:
            M := reduceLinDep(M, pp)[1]: # remove linearly dependent rows and columns from M
            fl := isActionMatrixFound(T, M, aB, B, nG, pp): # test if M is a template (optional)
            m, n := op(1, M): # template dimension
            sp := getSparsity(M): # template sparsity
            if fl and (m &lt; mo or (m = mo and sp &gt; spo)) then
                mo, no, spo := m, n, sp:
                print(sprintf(&quot;Smaller or sparser template found: [%d,%d], %a, %a, %a&quot;, m, n, round(100*sp), avars[j], ifelse(qb = 2, i, tord1))):
                saveData(prob, px, [m, n], sp, pp, vars, avars[j], tord, B, mon, qb):
            elif not fl then # should never get here
                error(&quot;Invalid action matrix, %1, %2, %3&quot;, i, avars[j], tord):
            end if:
            print(sprintf(&quot;%d%s, [%d,%d], %a, %a, %a&quot;, round(((k - 1)*nv + j)*N), &quot;%&quot;, m, n, round(100*sp), avars[j], ifelse(qb = 2, i, tord1))):
        end do:
    end do:
    mo, no, round(100*spo):
end proc:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L4448" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4833" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L4456" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L4439" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal">save
getTord,
readCM,
readNonGB,
saveData,
readData,
srt,
poly2matrix,
permuteColumns,
getSparsity,
getMatrixS,
getQuotients,
getPartition,
lsolve,
undetPoly,
getMatrixH,
undetPolyni,
getMatrixHni,
getMons,
corTemplate,
constructTemplate,
adjustParams,
adjustParamsS2,
adjustParamsS41,
isActionMatrixFound,
reduceKnownPivots,
reduceLinDep,
rectTord,
QBfilter,
iniProb,
genTemplate,
&quot;top_v0.81.m&quot;:</Text-field>
</Input>
</Group>
<Group hide-output="false" labelreference="L4441" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group hide-input="false" hide-output="false" labelreference="L4440" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-input="false" hide-output="false" labelreference="L4836" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-input="false" hide-output="false" labelreference="L4837" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4838" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" hide-output="false" labelreference="L4839" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" labelreference="L4840" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" labelreference="L4841" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group>
<Group view="code" labelreference="L4842" drawlabel="true" applyint="true" applyrational="true" applyexponent="false">
<Input><Text-field prompt="&gt; " style="Maple Input" layout="Normal"></Text-field>
</Input>
</Group></Presentation-Block>
</Worksheet>